# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_indexData_samsung_cpe_perfdata_udm__perfdata_indexData(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module samsung-cpe-perfdata-udm - based on the path /perfdata/indexData. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of indexes associated with this data point.
  """
  __slots__ = ('_path_helper', '_extmethods', '__indexId','__indexName','__indexValue',)

  _yang_name = 'indexData'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__indexId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..5']}), is_leaf=True, yang_name="indexId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)
    self.__indexName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indexName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__indexValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indexValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['perfdata', 'indexData']

  def _get_indexId(self):
    """
    Getter method for indexId, mapped from YANG variable /perfdata/indexData/indexId (uint16)

    YANG Description: Positional Index ID, unique
    """
    return self.__indexId
      
  def _set_indexId(self, v, load=False):
    """
    Setter method for indexId, mapped from YANG variable /perfdata/indexData/indexId (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indexId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indexId() directly.

    YANG Description: Positional Index ID, unique
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..5']}), is_leaf=True, yang_name="indexId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """indexId must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..5']}), is_leaf=True, yang_name="indexId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)""",
        })

    self.__indexId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_indexId(self):
    self.__indexId = YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['0..5']}), is_leaf=True, yang_name="indexId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)


  def _get_indexName(self):
    """
    Getter method for indexName, mapped from YANG variable /perfdata/indexData/indexName (string)

    YANG Description: Index Name depends on indexID and familyType,
typical CPE ID, Cell ID, Interface ID, CC ID, MCS ID
    """
    return self.__indexName
      
  def _set_indexName(self, v, load=False):
    """
    Setter method for indexName, mapped from YANG variable /perfdata/indexData/indexName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indexName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indexName() directly.

    YANG Description: Index Name depends on indexID and familyType,
typical CPE ID, Cell ID, Interface ID, CC ID, MCS ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="indexName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """indexName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indexName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__indexName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_indexName(self):
    self.__indexName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indexName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_indexValue(self):
    """
    Getter method for indexValue, mapped from YANG variable /perfdata/indexData/indexValue (string)

    YANG Description: The value associated with this indexId and familyType.
    """
    return self.__indexValue
      
  def _set_indexValue(self, v, load=False):
    """
    Setter method for indexValue, mapped from YANG variable /perfdata/indexData/indexValue (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indexValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indexValue() directly.

    YANG Description: The value associated with this indexId and familyType.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="indexValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """indexValue must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indexValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__indexValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_indexValue(self):
    self.__indexValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indexValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)

  indexId = __builtin__.property(_get_indexId, _set_indexId)
  indexName = __builtin__.property(_get_indexName, _set_indexName)
  indexValue = __builtin__.property(_get_indexValue, _set_indexValue)


  _pyangbind_elements = OrderedDict([('indexId', indexId), ('indexName', indexName), ('indexValue', indexValue), ])


class yc_payloadData_samsung_cpe_perfdata_udm__perfdata_payloadData(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module samsung-cpe-perfdata-udm - based on the path /perfdata/payloadData. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: the payload data associated with this data point
  """
  __slots__ = ('_path_helper', '_extmethods', '__typeId','__typeName','__typeValue','__valueType','__valueUnit',)

  _yang_name = 'payloadData'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__typeId = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="typeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)
    self.__typeName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="typeName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__typeValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="typeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__valueType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="valueType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__valueUnit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="valueUnit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['perfdata', 'payloadData']

  def _get_typeId(self):
    """
    Getter method for typeId, mapped from YANG variable /perfdata/payloadData/typeId (uint16)

    YANG Description: Positional dependency, determines the data type contained for this record.
    """
    return self.__typeId
      
  def _set_typeId(self, v, load=False):
    """
    Setter method for typeId, mapped from YANG variable /perfdata/payloadData/typeId (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_typeId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_typeId() directly.

    YANG Description: Positional dependency, determines the data type contained for this record.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="typeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """typeId must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="typeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)""",
        })

    self.__typeId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_typeId(self):
    self.__typeId = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="typeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)


  def _get_typeName(self):
    """
    Getter method for typeName, mapped from YANG variable /perfdata/payloadData/typeName (string)

    YANG Description: typeName depends on typeId and FamilyType, typical RxTotalPackets, DBler_Min, etc
    """
    return self.__typeName
      
  def _set_typeName(self, v, load=False):
    """
    Setter method for typeName, mapped from YANG variable /perfdata/payloadData/typeName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_typeName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_typeName() directly.

    YANG Description: typeName depends on typeId and FamilyType, typical RxTotalPackets, DBler_Min, etc
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="typeName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """typeName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="typeName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__typeName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_typeName(self):
    self.__typeName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="typeName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_typeValue(self):
    """
    Getter method for typeValue, mapped from YANG variable /perfdata/payloadData/typeValue (string)

    YANG Description: The value associated to this typeId and familyType.
    """
    return self.__typeValue
      
  def _set_typeValue(self, v, load=False):
    """
    Setter method for typeValue, mapped from YANG variable /perfdata/payloadData/typeValue (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_typeValue is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_typeValue() directly.

    YANG Description: The value associated to this typeId and familyType.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="typeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """typeValue must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="typeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__typeValue = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_typeValue(self):
    self.__typeValue = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="typeValue", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_valueType(self):
    """
    Getter method for valueType, mapped from YANG variable /perfdata/payloadData/valueType (string)

    YANG Description: DSM Output Format: typical float, unsigned int, int
    """
    return self.__valueType
      
  def _set_valueType(self, v, load=False):
    """
    Setter method for valueType, mapped from YANG variable /perfdata/payloadData/valueType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valueType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valueType() directly.

    YANG Description: DSM Output Format: typical float, unsigned int, int
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="valueType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valueType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="valueType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__valueType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valueType(self):
    self.__valueType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="valueType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_valueUnit(self):
    """
    Getter method for valueUnit, mapped from YANG variable /perfdata/payloadData/valueUnit (string)

    YANG Description: Units associated with typeValue as specified: typical %, degC, count, etc.
    """
    return self.__valueUnit
      
  def _set_valueUnit(self, v, load=False):
    """
    Setter method for valueUnit, mapped from YANG variable /perfdata/payloadData/valueUnit (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_valueUnit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_valueUnit() directly.

    YANG Description: Units associated with typeValue as specified: typical %, degC, count, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="valueUnit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """valueUnit must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="valueUnit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__valueUnit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_valueUnit(self):
    self.__valueUnit = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="valueUnit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)

  typeId = __builtin__.property(_get_typeId, _set_typeId)
  typeName = __builtin__.property(_get_typeName, _set_typeName)
  typeValue = __builtin__.property(_get_typeValue, _set_typeValue)
  valueType = __builtin__.property(_get_valueType, _set_valueType)
  valueUnit = __builtin__.property(_get_valueUnit, _set_valueUnit)


  _pyangbind_elements = OrderedDict([('typeId', typeId), ('typeName', typeName), ('typeValue', typeValue), ('valueType', valueType), ('valueUnit', valueUnit), ])


class yc_perfdata_samsung_cpe_perfdata_udm__perfdata(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module samsung-cpe-perfdata-udm - based on the path /perfdata. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__neId','__neType','__neVersion','__familyId','__annotatedFamilyId','__eventTime','__indexData','__payloadData',)

  _yang_name = 'perfdata'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__neId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__neType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__neVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__familyId = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="familyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)
    self.__annotatedFamilyId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="annotatedFamilyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    self.__eventTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="eventTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='cpe-date-and-time', is_config=True)
    self.__indexData = YANGDynClass(base=YANGListType("indexId",yc_indexData_samsung_cpe_perfdata_udm__perfdata_indexData, yang_name="indexData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='indexId', extensions=None), is_container='list', yang_name="indexData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)
    self.__payloadData = YANGDynClass(base=YANGListType("typeId",yc_payloadData_samsung_cpe_perfdata_udm__perfdata_payloadData, yang_name="payloadData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='typeId', extensions=None), is_container='list', yang_name="payloadData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['perfdata']

  def _get_neId(self):
    """
    Getter method for neId, mapped from YANG variable /perfdata/neId (string)

    YANG Description: the Network Element ID
    """
    return self.__neId
      
  def _set_neId(self, v, load=False):
    """
    Setter method for neId, mapped from YANG variable /perfdata/neId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neId() directly.

    YANG Description: the Network Element ID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__neId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neId(self):
    self.__neId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_neType(self):
    """
    Getter method for neType, mapped from YANG variable /perfdata/neType (string)

    YANG Description: Network Element Type for this data point, typical cpefama
    """
    return self.__neType
      
  def _set_neType(self, v, load=False):
    """
    Setter method for neType, mapped from YANG variable /perfdata/neType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neType() directly.

    YANG Description: Network Element Type for this data point, typical cpefama
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__neType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neType(self):
    self.__neType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_neVersion(self):
    """
    Getter method for neVersion, mapped from YANG variable /perfdata/neVersion (string)

    YANG Description: the Network Element Version
    """
    return self.__neVersion
      
  def _set_neVersion(self, v, load=False):
    """
    Setter method for neVersion, mapped from YANG variable /perfdata/neVersion (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_neVersion is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_neVersion() directly.

    YANG Description: the Network Element Version
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="neVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """neVersion must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__neVersion = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_neVersion(self):
    self.__neVersion = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="neVersion", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_familyId(self):
    """
    Getter method for familyId, mapped from YANG variable /perfdata/familyId (uint16)

    YANG Description: key identifier for the data type, typical 601, 702, etc.

familyId: annotatedFamilyId
601: CPE_RESOURCE
    This section provides statistics on the CPU, memory and disk resources used by internal
    applications in the system.
    - CPU usage: Average, maximum and minimum CPU usage in percentage (%).
    - Memory usage: Average, maximum and minimum DRAM usage in percentage (%).
    - Disk usage: Average, maximum and minimum disk usage in percentage (%).

 typeID typeName
    0  ControlCpuUsage  The average of CPU usage rate.
         This counter collects CPU usage and reports them to PM at sample intervals.
    1  MemoryUsage      The average of Memory usage rate.
         This counter collects memory usage and reports them to PM at sample intervals.
    2  DiskUsage        The average of Disk usage rate.
         This counter collects disk usage and reports them to PM at sample intervals.
    3  Temperature      The average of temperature(Degree Celsius)
         This counter collects temperature data and reports them to PM at sample intervals.

familyId: annotatedFamilyId
702: ETHERNET
    This section provides statistics on the ethernet interface(LAN side) packet counts.

 typeID typeName
    0  RxTotalPackets
         The total number of bytes received on the interface
    1  Rx Multicast Packets
         The total number of received packets, delivered by this layer to a higher layer,
         which were addressed to a multicast address at this layer.
         This counter increases when multicast packet is received during sample intervals.
    2  Rx Discard Packets
         The total number of inbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being delivered.
         This counter increases when it is discarded at RX driver during sample intervals.
    3  Rx Error Packets
         The total number of inbound packets that contained errors preventing them from being
         delivered to a higher-layer protocol.
         This counter increases when error packet is received during sample intervals.
    4  Tx Total Packets
         The total number of packets transmitted out of the interface.
    5  Tx Discard Packets
         The total number of outbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being transmitted.
         One possible reason for discarding such a packet could be to free up buffer space.
         This counter increases when it is discarded at TX driver during sample intervals.
    6  Tx Error Packets
         The total number of outbound packets that could not be transmitted because of errors.
         This counter increases when TX packet has error during sample intervals.

familyId: annotatedFamilyId
703: 5G Network
    This section provides statistics on the 5G interface(WAN side) packet counts.

 typeID typeName
    0  RxTotalPackets
         The total number of bytes received on the interface
    1  Rx Multicast Packets
         The total number of received packets, delivered by this layer to a higher layer,
         which were addressed to a multicast address at this layer.
         This counter increases when multicast packet is received during sample intervals.
    2  Rx Discard Packets
         The total number of inbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being delivered.
         This counter increases when it is discarded at RX driver during sample intervals.
    3  Rx Error Packets
         The total number of inbound packets that contained errors preventing them from being
         delivered to a higher-layer protocol.
         This counter increases when error packet is received during sample intervals.
    4  Tx Total Packets
         The total number of packets transmitted out of the interface.
    5  Tx Discard Packets
         The total number of outbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being transmitted.
         One possible reason for discarding such a packet could be to free up buffer space.
         This counter increases when it is discarded at TX driver during sample intervals.
    6  Tx Error Packets
         The total number of outbound packets that could not be transmitted because of errors.
         This counter increases when TX packet has error during sample intervals.

familyId: annotatedFamilyId
704: THROUGHPUT
    This section provides statistics on the min, max, average DL and UL throughput
    during the specified period.

 typeID typeName
    0  Min DL T-Put  The minimum value of downlink throughput during the period.
    1  Max DL T-Put  The maximum value of downlink throughput during the period.
    2  Avg DL T-Put  The average value of downlink throughput during the period.
    3  Min UL T-Put  The minimum value of uplink throughput during the period.
    4  Max UL T-Put  The maximum value of uplink throughput during the period.
    5  Avg UL T-Put  The average value of uplink throughput during the period.

familyId: annotatedFamilyId
901: BLER
    This section provides statistics on the BLER(Block Error Rate). BLER is the failure
    rate for the initial transmission and is a ratio of the number of times the first
    re-transmission was carried out to the number of times the initial transmission was
    carried out.

    Downlink BLER is calculated value of PDSCH BLER for the initial transmission during
    the collection interval. Uplink BLER is calculated value of PUSCH BLER for the initial
    transmission during the collection interval.

 typeID typeName
    0  DlBler_Min  The minimum value of downlink BLER data collected during the period.
    1  DlBler_Max  The maximum value of downlink BLER data collected during the period.
    2  DlBler_Avg  The average value of downlink BLER data collected during the period.
    3  UlBler_Min  The minimum value of uplink BLER data collected during the period.
    4  UlBler_Max  The maximum value of uplink BLER data collected during the period.
    5  UlBler_Avg  The average value of uplink BLER data collected during the period.

familyId: annotatedFamilyId
902: BRSRP
    This section provides statistics on the BRSRP(Beam Reference Signal Received Power).

 typeID typeName
    0  Brsrp_Min  The minimum value of BRSRP data collected during the period.
    1  Brsrp_Max  The maximum value of BRSRP data collected during the period.
    2  Brsrp_Avg  The average value of BRSRP data collected during the period.

familyId: annotatedFamilyId
903: KPI BRSRP
    This section provides KPI statistics on the BRSRP(Beam Reference Signal Received Power).

 typeID typeName
    0  BRSRP_5   The 5th percentile of BRSRP data in increasing order
    1  BRSRP_25  The 25th percentile of BRSRP data in increasing order
    2  BRSRP_50  The 50th percentile of BRSRP data in increasing order
    3  BRSRP_75  The 75th percentile of BRSRP data in increasing order
    4  BRSRP_95  The 95th percentile of BRSRP data in increasing order

familyId: annotatedFamilyId
904: SINR
    This section provides statistics on the SINR(Signal to Interference plus Noise Ratio).

 typeID typeName
    0  DlSinr_Min  The minimum value of downlink SINR data collected during the period.
    1  DlSinr_Max  The maximum value of downlink SINR data collected during the period.
    2  DlSinr_Avg  The average value of downlink SINR data collected during the period.

familyId: annotatedFamilyId
905: KPI SINR
    This section provides KPI statistics on the SINR(Signal to Interference plus Noise Ratio).

 typeID typeName
    0  SINR_5   The 5th percentile of SINR data in increasing order
    1  SINR_25  The 25th percentile of SINR data in increasing order
    2  SINR_50  The 50th percentile of SINR data in increasing order
    3  SINR_75  The 75th percentile of SINR data in increasing order
    4  SINR_95  The 95th percentile of SINR data in increasing order

familyId: annotatedFamilyId
906: KPI_PATH_LOSS
    This section provides KPI statistics on the path loss.

 typeID typeName
    0  DlPathLoss_5   The 5th percentile of downlink path loss data in increasing order
    1  DlPathLoss_25  The 25th percentile of downlink path loss data in increasing order
    2  DlPathLoss_50  The 50th percentile of downlink path loss data in increasing order
    3  DlPathLoss_75  The 75th percentile of downlink path loss data in increasing order
    4  DlPathLoss_95  The 95th percentile of downlink path loss data in increasing order

familyId: annotatedFamilyId
907: POWER
    This section provides statistics on the 5G power data.

 typeID typeName
    0  PuschTxPower_Avg
         The average value of PUSCH TX power data collected during the period.

familyId: annotatedFamilyId
910: RLF
    This section provides statistics on the RLF(Radio Link Failure).

    Various cases of RLF conditions based on Sec 5.3.11.3 of V5G_331 i.e.
    (1). Indication from RLC that the maximum number of retransmissions has been reached,
    (2). T310 expiry (after N310 out of sync indications have received from PHY) or
    (3). Random access problem indication from MAC or
    (4). Timing Alignment Timer expiration
    (5) T312 expiry.

 typeID typeName
    0  RLF_Total
         The total number of RLF events.
         This counter increases when RRC received RLF message(out_of_sync, MaxRetrans, and Rach_Fail)
         during the period.
    1  RLF_OutOfSync
         The number of RLF events due to out of sync.
         This counter increases when RRC received out_of_sync message during the period.
    2  RLF_MaxRetrans
         The number of RLF events due to max retransmission.
         This counter increases when RRC received MaxRetrans message during the period.
    3  RLF_RachFail	The number of RLF events due to RACH failure.
         This counter increases when RRC received Rach_Fail message during the period.
    4  RLF_Other
         The number of RLF events due to the other causes.
         This counter increases when RRC received other RLF message during the period.
    5  CallDrop_RLF
         The number of times RRC connection was dropped due to RLF.
         In otherword, call drops due to RRC Re-establishment failure.
         This counter increases when RRC failed in reestablishment procedure after RRC
         received RLF message during the period.

familyId: annotatedFamilyId
911: BEAM
    This section provides statistics on the 5G beam.

 typeID typeName
    0  BeamChangeBsiAttempt
         The number of times beam switch process was attempted. An attempt is counted either when
         a) BSI report is sent (if it triggered via xPDCCH order and beam switch indication
            bit was on and if there is new stronger beam compared to serving beam) or
         b) when UE receives BRS Beam Change Indication Mac CE (if BSI was triggered via xPDCCH
            order but without beam switch indication bit and using parameter
            BRSRP_BEAM_CHANGE_MARGIN_BSI in AU) or
         c) when UE sends an SR or RACH for UE initiated event based BSI based on beamTriggeringRSRPoffset
       Trigger condition indicates the trigger for BSI reporting. For example, 'UE initiated via SR',
       'UE initiated via RACH' or 'eNB triggered via xPDCCH order (with or without change indication)'
       and so on.
       This counter increases whenever UE tries to change beam triggered by beam switch indication in
       the BSI request from 5G NB.
    1  BeamChangeBsiSuccess
         The number of times beam switch process was successful
         This counter increases whenever beam change process was successful.
    2  BeamChangeBsiFail
         The number of times beam switch process failed. The following failure conditions should be
         captured as causes.
         For UE triggered BSI reporting
         1) SR fails(that is, no uplink grant)
         2) RACH fails
         3) CPE fails to receive BSI Beam Switch Indication after sending BSI
         4) CPE fails to acquire new beam after receiving beam switch indication for xPDCCH triggered
            BSI report
         5) CPE fails to acquire new beam after receiving beam switch indication
         This counter increases whenever beam change process failed.
    3  InitialBeamAcquisitionTime
         Initial access performance. The time interval from the cell selection request time to cell
         selection confirm time.
         Positive number or -1 representing no beam acquisition

familyId: annotatedFamilyId
912: RACH
    This section provides statistics on the RACH(Random Access CHannel).

 typeID typeName
    0  RachFailureCount
         The total number of RACH failure(retry) during the period.
         If Random Access fails due to Random Access Response Timeout, Contention Resolution Timeout or
         Contention Resolution Fail in UE, RachFailureCount will be counted.
         This counter increases when Random Access fails due to Random Access Response Timeout,
         Contention Resolution Timeout or Contention Resolution Fail in UE.
    1  RachAttemptCount
         The total number of RACH attempt during the period.
         Attempt count for success of Random Access Procedure. Random Access Procedure can be retried
         for RACH Procedure Success until receiving stop message from RRC layer.
         This counter increases whenever Random Access Procedure is attempted.
    2  RachAttemptCountAvg
         The average number of RACH attempt for Success of Random Access Procedure during the period.
         This is calculated as the average of RachAttemptCount data during the period.
    3  TimingAdvanceRar
         Timing advance value received in the last RAR message received in the reporting window.

familyId: annotatedFamilyId
913: SERVICE
    This section provides statistics on the 5G service.

 typeID typeName
    0  RrcConnectionTime
         The RRC connection time. The total time while the RRC connection is maintained.
    1  RrcConnectionComplete
         The number of RRC Connection Complete
         This counter increases when RRC received RRCConnectionComplete message during the period.
    2  RrcConnectionRequest
         The number of RRC Connection Request
         This counter increases when RRC received RRCConnectionRequest message during the period.

familyId: annotatedFamilyId
914: MAC_THROUGHPUT
    This section provides statistics on the 5G MAC throughput.

    It is critical to support effective throughput. Effective throughput provides better
    throughput numbers to operator based on actual TTI utilization.

 typeID typeName
    0  PDSCHTput_Tot
         The total xPDSCH packet bytes
         This counter increases when xPDSCH packet is transmitted.
    1  PDSCHTput_Min
         The minimum xPDSCH packet bytes per sec (kbps, k=1000)
         This is updated with the minimum xPDSCH packet bytes per sec during the period.
    2  PDSCHTput_Max
         The peak xPDSCH packet bytes per sec (kbps, k=1000)
         This is updated with the maximum xPDSCH packet bytes per sec during the period.
    3  PDSCHTput_Avg
         The average xPDSCH throughput (kbps, k=1000)
         This is calculated as the average of xPDSCH throughput data during the period.
    4  PUSCHTput_Tot
         The total xPUSCH packet bytes
         This counter increases when xPUSCH packet is transmitted.
    5  PUSCHTput_Min
         The minimum xPUSCH packet bytes per sec (kbps, k=1000)
         This is updated with the minimum xPUSCH packet bytes per sec during the period.
    6  PUSCHTput_Max
         The peak xPUSCH packet bytes per sec (kbps, k=1000)
         This is updated with the maximum xPUSCH packet bytes per sec during the period.
    7  PUSCHTput_Avg
         The average xPUSCH throughput (kbps, k=1000)
         This is calculated as the average of xPUSCH throughput data during the period.
    8  PDSCH_EffectiveTput_Tot
         The total amount of PDSCH bits received over the total number of allocated downlink TTIs.
         This counter increases when xPDSCH packet is transmitted over the allocated downlink TTIs.
    9  PDSCH_EffectiveTput_Min
         The minimum xPDSCH effective throughput per sec (kbps, k=1000)
         This is updated with the minimum xPDSCH effective throughput per sec during the period.
    10  PDSCH_EffectiveTput_Max
          The maximum xPDSCH effective throughput per sec (kbps, k=1000)
          This is updated with the maximum xPDSCH effective throughput per sec during the period.
    11  PDSCH_EffectiveTput_Avg
          The average xPDSCH effective throughput per sec (kbps, k=1000)
          This is calculated as the average of xPDSCH effective throughput data during the period.
    12  PUSCH_EffectiveTput_Tot
          Total amount of PUSCH bits transmitted over the total number of allocated uplink TTIs.
          This counter increases when xPUSCH packet is transmitted over the allocated downlink TTIs.
    13  PUSCH_EffectiveTput_Min
          The minimum xPUSCH effective throughput per sec (kbps, k=1000)
          This is updated with the minimum xPUSCH effective throughput per sec during the period.
    14  PUSCH_EffectiveTput_Max
          The maximum xPUSCH effective throughput per sec (kbps, k=1000)
          This is updated with the maximum xPUSCH effective throughput per sec during the period.
    15  PUSCH_EffectiveTput_Avg
          The average xPUSCH effective throughput per sec (kbps, k=1000)
          This is calculated as the average of xPUSCH effective throughput data during the period.

familyId: annotatedFamilyId
915: RLC_THROUGHPUT
    This section provides statistics on the 5G RLC throughput.

 typeID typeName
    0  RlcDlTput_Tot
         The total downlink packet bytes
         This counter increases when RLC downlink packet is transmitted.
    1  RlcDlTput_Min
         The minimum downlink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the minimum RLC downlink throughput data during the period.
    2  RlcDlTput_Max
         The maximum downlink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the maximum RLC downlink throughput data during the period.
    3  RlcDlTput_Avg
         The average downlink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is calculated as the average of RLC downlink throughput data during the period.
    4  RlcUlTput_Tot
         The total uplink packet bytes
         This counter increases when RLC uplink packet is transmitted.
    5  RlcUlTput_Min
         The minimum uplink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the minimum RLC uplink throughput data during the period.
    6  RlcUlTput_Max
         The maximum uplink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the maximum RLC uplink throughput data during the period.
    7  RlcUlTput_Avg
         The average uplink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is calculated as the average of RLC uplink throughput data during the period.

familyId: annotatedFamilyId
916: AMC
    This section provides statistics on the 5G AMC(Adaptive Modulation and Coding).

 typeID typeName
    0  DLTransmittedCQI_wAvg
         The weighted average value of DLTransmittedCQI0 ~ DLTransmittedCQ15.
         This is calculated as
         (0 *DLTransmittedCQI0 + 1* DLTransmittedCQI1 +….+15*DLTransmittedCQI15) /
         (DLTransmittedCQI0 + DLTransmittedCQI1 +..+DLTransmittedCQI15)
         CQI is measured for every CSI report and is used as raw data of this calculation.
    1  DLTransmittedRI_wAvg
         The weighted average value of RI. This is calculated as
         (1*DLTransmittedRI0 + 2* DLTransmittedRI1) /
         (DLTransmittedRI0 +DLTransmittedRI1)
         RI is measured for every CSI report and is used as raw data of this calculation.
    2  DLReceivedLayer1
         The number of PDSCH assignments for the layer1
         This counter increases for every PDSCH assignment for the layer1.
    3  DLReceivedLayer2
         The number of PDSCH assignments for the layer2
         This counter increases for every PDSCH assignment for the layer2.
    4  ULTransmittedLayer1
         The number of PUSCH assignments for the layer1
         This counter increases for every PUSCH assignment for the layer1.
    5  ULTransmittedLayer2
       The number of PUSCH assignments for the layer2
       This counter increases for every PUSCH assignment for the layer2.

familyId: annotatedFamilyId
917: SCHEDULER
    This section provides statistics on the 5G scheduler.

 typeID typeName
    0  PrbDl_Avg
         The usage rate (percentage) of the Physical Resource Block on the downlink
         PDSCH among the total Physical Resource Block
    1  PrbUl_Avg
         The usage rate (percentage) of the Physical Resource Block on the uplink
         PUSCH among the total Physical Resource Block

familyId: annotatedFamilyId
918: MCS
    This section provides statistics on the 5G MCS(Modulation Coding Scheme).

 typeID typeName
    0  DLTransmitMCS
         The total number of times PDSCH was transmitted at MCS0~14
         This counter increases whenever PDSCH was transmitted at each MCS.
    1  ULTransmitMCS
         The total number of times PUSCH was transmitted at MCS0~14
         This counter increases whenever PUSCH was transmitted at each MCS.

familyId: annotatedFamilyId
919: HANDOVER
    This section provides statistics on the 5G handover.

 typeID typeName
    0  UeBasedHoAttempt
         Handover attempt count
         Note: For UE based handover start of attempt should be considered when A3 event
         is reported by UE.
         This counter increases when RRM sent HO_ind message to RRC during the period.
    1  UeBasedHoSuccess
         Handover success count
         This counter increases when RRC attached successfully during the period.

    """
    return self.__familyId
      
  def _set_familyId(self, v, load=False):
    """
    Setter method for familyId, mapped from YANG variable /perfdata/familyId (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_familyId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_familyId() directly.

    YANG Description: key identifier for the data type, typical 601, 702, etc.

familyId: annotatedFamilyId
601: CPE_RESOURCE
    This section provides statistics on the CPU, memory and disk resources used by internal
    applications in the system.
    - CPU usage: Average, maximum and minimum CPU usage in percentage (%).
    - Memory usage: Average, maximum and minimum DRAM usage in percentage (%).
    - Disk usage: Average, maximum and minimum disk usage in percentage (%).

 typeID typeName
    0  ControlCpuUsage  The average of CPU usage rate.
         This counter collects CPU usage and reports them to PM at sample intervals.
    1  MemoryUsage      The average of Memory usage rate.
         This counter collects memory usage and reports them to PM at sample intervals.
    2  DiskUsage        The average of Disk usage rate.
         This counter collects disk usage and reports them to PM at sample intervals.
    3  Temperature      The average of temperature(Degree Celsius)
         This counter collects temperature data and reports them to PM at sample intervals.

familyId: annotatedFamilyId
702: ETHERNET
    This section provides statistics on the ethernet interface(LAN side) packet counts.

 typeID typeName
    0  RxTotalPackets
         The total number of bytes received on the interface
    1  Rx Multicast Packets
         The total number of received packets, delivered by this layer to a higher layer,
         which were addressed to a multicast address at this layer.
         This counter increases when multicast packet is received during sample intervals.
    2  Rx Discard Packets
         The total number of inbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being delivered.
         This counter increases when it is discarded at RX driver during sample intervals.
    3  Rx Error Packets
         The total number of inbound packets that contained errors preventing them from being
         delivered to a higher-layer protocol.
         This counter increases when error packet is received during sample intervals.
    4  Tx Total Packets
         The total number of packets transmitted out of the interface.
    5  Tx Discard Packets
         The total number of outbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being transmitted.
         One possible reason for discarding such a packet could be to free up buffer space.
         This counter increases when it is discarded at TX driver during sample intervals.
    6  Tx Error Packets
         The total number of outbound packets that could not be transmitted because of errors.
         This counter increases when TX packet has error during sample intervals.

familyId: annotatedFamilyId
703: 5G Network
    This section provides statistics on the 5G interface(WAN side) packet counts.

 typeID typeName
    0  RxTotalPackets
         The total number of bytes received on the interface
    1  Rx Multicast Packets
         The total number of received packets, delivered by this layer to a higher layer,
         which were addressed to a multicast address at this layer.
         This counter increases when multicast packet is received during sample intervals.
    2  Rx Discard Packets
         The total number of inbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being delivered.
         This counter increases when it is discarded at RX driver during sample intervals.
    3  Rx Error Packets
         The total number of inbound packets that contained errors preventing them from being
         delivered to a higher-layer protocol.
         This counter increases when error packet is received during sample intervals.
    4  Tx Total Packets
         The total number of packets transmitted out of the interface.
    5  Tx Discard Packets
         The total number of outbound packets which were chosen to be discarded even though no
         errors had been detected to prevent their being transmitted.
         One possible reason for discarding such a packet could be to free up buffer space.
         This counter increases when it is discarded at TX driver during sample intervals.
    6  Tx Error Packets
         The total number of outbound packets that could not be transmitted because of errors.
         This counter increases when TX packet has error during sample intervals.

familyId: annotatedFamilyId
704: THROUGHPUT
    This section provides statistics on the min, max, average DL and UL throughput
    during the specified period.

 typeID typeName
    0  Min DL T-Put  The minimum value of downlink throughput during the period.
    1  Max DL T-Put  The maximum value of downlink throughput during the period.
    2  Avg DL T-Put  The average value of downlink throughput during the period.
    3  Min UL T-Put  The minimum value of uplink throughput during the period.
    4  Max UL T-Put  The maximum value of uplink throughput during the period.
    5  Avg UL T-Put  The average value of uplink throughput during the period.

familyId: annotatedFamilyId
901: BLER
    This section provides statistics on the BLER(Block Error Rate). BLER is the failure
    rate for the initial transmission and is a ratio of the number of times the first
    re-transmission was carried out to the number of times the initial transmission was
    carried out.

    Downlink BLER is calculated value of PDSCH BLER for the initial transmission during
    the collection interval. Uplink BLER is calculated value of PUSCH BLER for the initial
    transmission during the collection interval.

 typeID typeName
    0  DlBler_Min  The minimum value of downlink BLER data collected during the period.
    1  DlBler_Max  The maximum value of downlink BLER data collected during the period.
    2  DlBler_Avg  The average value of downlink BLER data collected during the period.
    3  UlBler_Min  The minimum value of uplink BLER data collected during the period.
    4  UlBler_Max  The maximum value of uplink BLER data collected during the period.
    5  UlBler_Avg  The average value of uplink BLER data collected during the period.

familyId: annotatedFamilyId
902: BRSRP
    This section provides statistics on the BRSRP(Beam Reference Signal Received Power).

 typeID typeName
    0  Brsrp_Min  The minimum value of BRSRP data collected during the period.
    1  Brsrp_Max  The maximum value of BRSRP data collected during the period.
    2  Brsrp_Avg  The average value of BRSRP data collected during the period.

familyId: annotatedFamilyId
903: KPI BRSRP
    This section provides KPI statistics on the BRSRP(Beam Reference Signal Received Power).

 typeID typeName
    0  BRSRP_5   The 5th percentile of BRSRP data in increasing order
    1  BRSRP_25  The 25th percentile of BRSRP data in increasing order
    2  BRSRP_50  The 50th percentile of BRSRP data in increasing order
    3  BRSRP_75  The 75th percentile of BRSRP data in increasing order
    4  BRSRP_95  The 95th percentile of BRSRP data in increasing order

familyId: annotatedFamilyId
904: SINR
    This section provides statistics on the SINR(Signal to Interference plus Noise Ratio).

 typeID typeName
    0  DlSinr_Min  The minimum value of downlink SINR data collected during the period.
    1  DlSinr_Max  The maximum value of downlink SINR data collected during the period.
    2  DlSinr_Avg  The average value of downlink SINR data collected during the period.

familyId: annotatedFamilyId
905: KPI SINR
    This section provides KPI statistics on the SINR(Signal to Interference plus Noise Ratio).

 typeID typeName
    0  SINR_5   The 5th percentile of SINR data in increasing order
    1  SINR_25  The 25th percentile of SINR data in increasing order
    2  SINR_50  The 50th percentile of SINR data in increasing order
    3  SINR_75  The 75th percentile of SINR data in increasing order
    4  SINR_95  The 95th percentile of SINR data in increasing order

familyId: annotatedFamilyId
906: KPI_PATH_LOSS
    This section provides KPI statistics on the path loss.

 typeID typeName
    0  DlPathLoss_5   The 5th percentile of downlink path loss data in increasing order
    1  DlPathLoss_25  The 25th percentile of downlink path loss data in increasing order
    2  DlPathLoss_50  The 50th percentile of downlink path loss data in increasing order
    3  DlPathLoss_75  The 75th percentile of downlink path loss data in increasing order
    4  DlPathLoss_95  The 95th percentile of downlink path loss data in increasing order

familyId: annotatedFamilyId
907: POWER
    This section provides statistics on the 5G power data.

 typeID typeName
    0  PuschTxPower_Avg
         The average value of PUSCH TX power data collected during the period.

familyId: annotatedFamilyId
910: RLF
    This section provides statistics on the RLF(Radio Link Failure).

    Various cases of RLF conditions based on Sec 5.3.11.3 of V5G_331 i.e.
    (1). Indication from RLC that the maximum number of retransmissions has been reached,
    (2). T310 expiry (after N310 out of sync indications have received from PHY) or
    (3). Random access problem indication from MAC or
    (4). Timing Alignment Timer expiration
    (5) T312 expiry.

 typeID typeName
    0  RLF_Total
         The total number of RLF events.
         This counter increases when RRC received RLF message(out_of_sync, MaxRetrans, and Rach_Fail)
         during the period.
    1  RLF_OutOfSync
         The number of RLF events due to out of sync.
         This counter increases when RRC received out_of_sync message during the period.
    2  RLF_MaxRetrans
         The number of RLF events due to max retransmission.
         This counter increases when RRC received MaxRetrans message during the period.
    3  RLF_RachFail	The number of RLF events due to RACH failure.
         This counter increases when RRC received Rach_Fail message during the period.
    4  RLF_Other
         The number of RLF events due to the other causes.
         This counter increases when RRC received other RLF message during the period.
    5  CallDrop_RLF
         The number of times RRC connection was dropped due to RLF.
         In otherword, call drops due to RRC Re-establishment failure.
         This counter increases when RRC failed in reestablishment procedure after RRC
         received RLF message during the period.

familyId: annotatedFamilyId
911: BEAM
    This section provides statistics on the 5G beam.

 typeID typeName
    0  BeamChangeBsiAttempt
         The number of times beam switch process was attempted. An attempt is counted either when
         a) BSI report is sent (if it triggered via xPDCCH order and beam switch indication
            bit was on and if there is new stronger beam compared to serving beam) or
         b) when UE receives BRS Beam Change Indication Mac CE (if BSI was triggered via xPDCCH
            order but without beam switch indication bit and using parameter
            BRSRP_BEAM_CHANGE_MARGIN_BSI in AU) or
         c) when UE sends an SR or RACH for UE initiated event based BSI based on beamTriggeringRSRPoffset
       Trigger condition indicates the trigger for BSI reporting. For example, 'UE initiated via SR',
       'UE initiated via RACH' or 'eNB triggered via xPDCCH order (with or without change indication)'
       and so on.
       This counter increases whenever UE tries to change beam triggered by beam switch indication in
       the BSI request from 5G NB.
    1  BeamChangeBsiSuccess
         The number of times beam switch process was successful
         This counter increases whenever beam change process was successful.
    2  BeamChangeBsiFail
         The number of times beam switch process failed. The following failure conditions should be
         captured as causes.
         For UE triggered BSI reporting
         1) SR fails(that is, no uplink grant)
         2) RACH fails
         3) CPE fails to receive BSI Beam Switch Indication after sending BSI
         4) CPE fails to acquire new beam after receiving beam switch indication for xPDCCH triggered
            BSI report
         5) CPE fails to acquire new beam after receiving beam switch indication
         This counter increases whenever beam change process failed.
    3  InitialBeamAcquisitionTime
         Initial access performance. The time interval from the cell selection request time to cell
         selection confirm time.
         Positive number or -1 representing no beam acquisition

familyId: annotatedFamilyId
912: RACH
    This section provides statistics on the RACH(Random Access CHannel).

 typeID typeName
    0  RachFailureCount
         The total number of RACH failure(retry) during the period.
         If Random Access fails due to Random Access Response Timeout, Contention Resolution Timeout or
         Contention Resolution Fail in UE, RachFailureCount will be counted.
         This counter increases when Random Access fails due to Random Access Response Timeout,
         Contention Resolution Timeout or Contention Resolution Fail in UE.
    1  RachAttemptCount
         The total number of RACH attempt during the period.
         Attempt count for success of Random Access Procedure. Random Access Procedure can be retried
         for RACH Procedure Success until receiving stop message from RRC layer.
         This counter increases whenever Random Access Procedure is attempted.
    2  RachAttemptCountAvg
         The average number of RACH attempt for Success of Random Access Procedure during the period.
         This is calculated as the average of RachAttemptCount data during the period.
    3  TimingAdvanceRar
         Timing advance value received in the last RAR message received in the reporting window.

familyId: annotatedFamilyId
913: SERVICE
    This section provides statistics on the 5G service.

 typeID typeName
    0  RrcConnectionTime
         The RRC connection time. The total time while the RRC connection is maintained.
    1  RrcConnectionComplete
         The number of RRC Connection Complete
         This counter increases when RRC received RRCConnectionComplete message during the period.
    2  RrcConnectionRequest
         The number of RRC Connection Request
         This counter increases when RRC received RRCConnectionRequest message during the period.

familyId: annotatedFamilyId
914: MAC_THROUGHPUT
    This section provides statistics on the 5G MAC throughput.

    It is critical to support effective throughput. Effective throughput provides better
    throughput numbers to operator based on actual TTI utilization.

 typeID typeName
    0  PDSCHTput_Tot
         The total xPDSCH packet bytes
         This counter increases when xPDSCH packet is transmitted.
    1  PDSCHTput_Min
         The minimum xPDSCH packet bytes per sec (kbps, k=1000)
         This is updated with the minimum xPDSCH packet bytes per sec during the period.
    2  PDSCHTput_Max
         The peak xPDSCH packet bytes per sec (kbps, k=1000)
         This is updated with the maximum xPDSCH packet bytes per sec during the period.
    3  PDSCHTput_Avg
         The average xPDSCH throughput (kbps, k=1000)
         This is calculated as the average of xPDSCH throughput data during the period.
    4  PUSCHTput_Tot
         The total xPUSCH packet bytes
         This counter increases when xPUSCH packet is transmitted.
    5  PUSCHTput_Min
         The minimum xPUSCH packet bytes per sec (kbps, k=1000)
         This is updated with the minimum xPUSCH packet bytes per sec during the period.
    6  PUSCHTput_Max
         The peak xPUSCH packet bytes per sec (kbps, k=1000)
         This is updated with the maximum xPUSCH packet bytes per sec during the period.
    7  PUSCHTput_Avg
         The average xPUSCH throughput (kbps, k=1000)
         This is calculated as the average of xPUSCH throughput data during the period.
    8  PDSCH_EffectiveTput_Tot
         The total amount of PDSCH bits received over the total number of allocated downlink TTIs.
         This counter increases when xPDSCH packet is transmitted over the allocated downlink TTIs.
    9  PDSCH_EffectiveTput_Min
         The minimum xPDSCH effective throughput per sec (kbps, k=1000)
         This is updated with the minimum xPDSCH effective throughput per sec during the period.
    10  PDSCH_EffectiveTput_Max
          The maximum xPDSCH effective throughput per sec (kbps, k=1000)
          This is updated with the maximum xPDSCH effective throughput per sec during the period.
    11  PDSCH_EffectiveTput_Avg
          The average xPDSCH effective throughput per sec (kbps, k=1000)
          This is calculated as the average of xPDSCH effective throughput data during the period.
    12  PUSCH_EffectiveTput_Tot
          Total amount of PUSCH bits transmitted over the total number of allocated uplink TTIs.
          This counter increases when xPUSCH packet is transmitted over the allocated downlink TTIs.
    13  PUSCH_EffectiveTput_Min
          The minimum xPUSCH effective throughput per sec (kbps, k=1000)
          This is updated with the minimum xPUSCH effective throughput per sec during the period.
    14  PUSCH_EffectiveTput_Max
          The maximum xPUSCH effective throughput per sec (kbps, k=1000)
          This is updated with the maximum xPUSCH effective throughput per sec during the period.
    15  PUSCH_EffectiveTput_Avg
          The average xPUSCH effective throughput per sec (kbps, k=1000)
          This is calculated as the average of xPUSCH effective throughput data during the period.

familyId: annotatedFamilyId
915: RLC_THROUGHPUT
    This section provides statistics on the 5G RLC throughput.

 typeID typeName
    0  RlcDlTput_Tot
         The total downlink packet bytes
         This counter increases when RLC downlink packet is transmitted.
    1  RlcDlTput_Min
         The minimum downlink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the minimum RLC downlink throughput data during the period.
    2  RlcDlTput_Max
         The maximum downlink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the maximum RLC downlink throughput data during the period.
    3  RlcDlTput_Avg
         The average downlink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is calculated as the average of RLC downlink throughput data during the period.
    4  RlcUlTput_Tot
         The total uplink packet bytes
         This counter increases when RLC uplink packet is transmitted.
    5  RlcUlTput_Min
         The minimum uplink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the minimum RLC uplink throughput data during the period.
    6  RlcUlTput_Max
         The maximum uplink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is updated with the maximum RLC uplink throughput data during the period.
    7  RlcUlTput_Avg
         The average uplink packet bytes in RLC sublayer per sec (kbps, k=1000)
         This is calculated as the average of RLC uplink throughput data during the period.

familyId: annotatedFamilyId
916: AMC
    This section provides statistics on the 5G AMC(Adaptive Modulation and Coding).

 typeID typeName
    0  DLTransmittedCQI_wAvg
         The weighted average value of DLTransmittedCQI0 ~ DLTransmittedCQ15.
         This is calculated as
         (0 *DLTransmittedCQI0 + 1* DLTransmittedCQI1 +….+15*DLTransmittedCQI15) /
         (DLTransmittedCQI0 + DLTransmittedCQI1 +..+DLTransmittedCQI15)
         CQI is measured for every CSI report and is used as raw data of this calculation.
    1  DLTransmittedRI_wAvg
         The weighted average value of RI. This is calculated as
         (1*DLTransmittedRI0 + 2* DLTransmittedRI1) /
         (DLTransmittedRI0 +DLTransmittedRI1)
         RI is measured for every CSI report and is used as raw data of this calculation.
    2  DLReceivedLayer1
         The number of PDSCH assignments for the layer1
         This counter increases for every PDSCH assignment for the layer1.
    3  DLReceivedLayer2
         The number of PDSCH assignments for the layer2
         This counter increases for every PDSCH assignment for the layer2.
    4  ULTransmittedLayer1
         The number of PUSCH assignments for the layer1
         This counter increases for every PUSCH assignment for the layer1.
    5  ULTransmittedLayer2
       The number of PUSCH assignments for the layer2
       This counter increases for every PUSCH assignment for the layer2.

familyId: annotatedFamilyId
917: SCHEDULER
    This section provides statistics on the 5G scheduler.

 typeID typeName
    0  PrbDl_Avg
         The usage rate (percentage) of the Physical Resource Block on the downlink
         PDSCH among the total Physical Resource Block
    1  PrbUl_Avg
         The usage rate (percentage) of the Physical Resource Block on the uplink
         PUSCH among the total Physical Resource Block

familyId: annotatedFamilyId
918: MCS
    This section provides statistics on the 5G MCS(Modulation Coding Scheme).

 typeID typeName
    0  DLTransmitMCS
         The total number of times PDSCH was transmitted at MCS0~14
         This counter increases whenever PDSCH was transmitted at each MCS.
    1  ULTransmitMCS
         The total number of times PUSCH was transmitted at MCS0~14
         This counter increases whenever PUSCH was transmitted at each MCS.

familyId: annotatedFamilyId
919: HANDOVER
    This section provides statistics on the 5G handover.

 typeID typeName
    0  UeBasedHoAttempt
         Handover attempt count
         Note: For UE based handover start of attempt should be considered when A3 event
         is reported by UE.
         This counter increases when RRM sent HO_ind message to RRC during the period.
    1  UeBasedHoSuccess
         Handover success count
         This counter increases when RRC attached successfully during the period.

    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="familyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """familyId must be of a type compatible with uint16""",
          'defined-type': "uint16",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="familyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)""",
        })

    self.__familyId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_familyId(self):
    self.__familyId = YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="familyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='uint16', is_config=True)


  def _get_annotatedFamilyId(self):
    """
    Getter method for annotatedFamilyId, mapped from YANG variable /perfdata/annotatedFamilyId (string)

    YANG Description: Description of the familyId, typcical: CPE_RESOURCE, ETHERNET, etc.
    """
    return self.__annotatedFamilyId
      
  def _set_annotatedFamilyId(self, v, load=False):
    """
    Setter method for annotatedFamilyId, mapped from YANG variable /perfdata/annotatedFamilyId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_annotatedFamilyId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_annotatedFamilyId() directly.

    YANG Description: Description of the familyId, typcical: CPE_RESOURCE, ETHERNET, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="annotatedFamilyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """annotatedFamilyId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="annotatedFamilyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)""",
        })

    self.__annotatedFamilyId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_annotatedFamilyId(self):
    self.__annotatedFamilyId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="annotatedFamilyId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='string', is_config=True)


  def _get_eventTime(self):
    """
    Getter method for eventTime, mapped from YANG variable /perfdata/eventTime (cpe-date-and-time)

    YANG Description: event time as reported by samsung, format yyyy-mm-ddTHH:MI:SS+HH:MI
    """
    return self.__eventTime
      
  def _set_eventTime(self, v, load=False):
    """
    Setter method for eventTime, mapped from YANG variable /perfdata/eventTime (cpe-date-and-time)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_eventTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_eventTime() directly.

    YANG Description: event time as reported by samsung, format yyyy-mm-ddTHH:MI:SS+HH:MI
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="eventTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='cpe-date-and-time', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """eventTime must be of a type compatible with cpe-date-and-time""",
          'defined-type': "samsung-cpe-perfdata-udm:cpe-date-and-time",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="eventTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='cpe-date-and-time', is_config=True)""",
        })

    self.__eventTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_eventTime(self):
    self.__eventTime = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(Z|[\\+\\-]\\d{2}:\\d{2})'}), is_leaf=True, yang_name="eventTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='cpe-date-and-time', is_config=True)


  def _get_indexData(self):
    """
    Getter method for indexData, mapped from YANG variable /perfdata/indexData (list)

    YANG Description: List of indexes associated with this data point.
    """
    return self.__indexData
      
  def _set_indexData(self, v, load=False):
    """
    Setter method for indexData, mapped from YANG variable /perfdata/indexData (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indexData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indexData() directly.

    YANG Description: List of indexes associated with this data point.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("indexId",yc_indexData_samsung_cpe_perfdata_udm__perfdata_indexData, yang_name="indexData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='indexId', extensions=None), is_container='list', yang_name="indexData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """indexData must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("indexId",yc_indexData_samsung_cpe_perfdata_udm__perfdata_indexData, yang_name="indexData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='indexId', extensions=None), is_container='list', yang_name="indexData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)""",
        })

    self.__indexData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_indexData(self):
    self.__indexData = YANGDynClass(base=YANGListType("indexId",yc_indexData_samsung_cpe_perfdata_udm__perfdata_indexData, yang_name="indexData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='indexId', extensions=None), is_container='list', yang_name="indexData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)


  def _get_payloadData(self):
    """
    Getter method for payloadData, mapped from YANG variable /perfdata/payloadData (list)

    YANG Description: the payload data associated with this data point
    """
    return self.__payloadData
      
  def _set_payloadData(self, v, load=False):
    """
    Setter method for payloadData, mapped from YANG variable /perfdata/payloadData (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_payloadData is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_payloadData() directly.

    YANG Description: the payload data associated with this data point
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("typeId",yc_payloadData_samsung_cpe_perfdata_udm__perfdata_payloadData, yang_name="payloadData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='typeId', extensions=None), is_container='list', yang_name="payloadData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """payloadData must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("typeId",yc_payloadData_samsung_cpe_perfdata_udm__perfdata_payloadData, yang_name="payloadData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='typeId', extensions=None), is_container='list', yang_name="payloadData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)""",
        })

    self.__payloadData = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_payloadData(self):
    self.__payloadData = YANGDynClass(base=YANGListType("typeId",yc_payloadData_samsung_cpe_perfdata_udm__perfdata_payloadData, yang_name="payloadData", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='typeId', extensions=None), is_container='list', yang_name="payloadData", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='list', is_config=True)

  neId = __builtin__.property(_get_neId, _set_neId)
  neType = __builtin__.property(_get_neType, _set_neType)
  neVersion = __builtin__.property(_get_neVersion, _set_neVersion)
  familyId = __builtin__.property(_get_familyId, _set_familyId)
  annotatedFamilyId = __builtin__.property(_get_annotatedFamilyId, _set_annotatedFamilyId)
  eventTime = __builtin__.property(_get_eventTime, _set_eventTime)
  indexData = __builtin__.property(_get_indexData, _set_indexData)
  payloadData = __builtin__.property(_get_payloadData, _set_payloadData)


  _pyangbind_elements = OrderedDict([('neId', neId), ('neType', neType), ('neVersion', neVersion), ('familyId', familyId), ('annotatedFamilyId', annotatedFamilyId), ('eventTime', eventTime), ('indexData', indexData), ('payloadData', payloadData), ])


class samsung_cpe_perfdata_udm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module samsung-cpe-perfdata-udm - based on the path /samsung-cpe-perfdata-udm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Samsung Verizon CPE Performance Data in Unified Data Model
  """
  __slots__ = ('_path_helper', '_extmethods', '__perfdata',)

  _yang_name = 'samsung-cpe-perfdata-udm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__perfdata = YANGDynClass(base=yc_perfdata_samsung_cpe_perfdata_udm__perfdata, is_container='container', yang_name="perfdata", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_perfdata(self):
    """
    Getter method for perfdata, mapped from YANG variable /perfdata (container)
    """
    return self.__perfdata
      
  def _set_perfdata(self, v, load=False):
    """
    Setter method for perfdata, mapped from YANG variable /perfdata (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_perfdata is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_perfdata() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_perfdata_samsung_cpe_perfdata_udm__perfdata, is_container='container', yang_name="perfdata", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """perfdata must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_perfdata_samsung_cpe_perfdata_udm__perfdata, is_container='container', yang_name="perfdata", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='container', is_config=True)""",
        })

    self.__perfdata = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_perfdata(self):
    self.__perfdata = YANGDynClass(base=yc_perfdata_samsung_cpe_perfdata_udm__perfdata, is_container='container', yang_name="perfdata", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://enmv.verizon.com/module', defining_module='samsung-cpe-perfdata-udm', yang_type='container', is_config=True)

  perfdata = __builtin__.property(_get_perfdata, _set_perfdata)


  _pyangbind_elements = OrderedDict([('perfdata', perfdata), ])


