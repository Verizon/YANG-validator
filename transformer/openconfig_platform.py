#
# Copyright Verizon Inc.
# Licensed under the terms of the Apache License 2.0 license.  See LICENSE file in project root for terms.
#
# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class vz_udm_platform_equipment_holder(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vz-udm-platform-equipment-holder - based on the path /vz-udm-platform-equipment-holder. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: model to describe the physical equipment holder
  """
  _pyangbind_elements = {}

  

class vz_udm_platform_equipment_model(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vz-udm-platform-equipment-model - based on the path /vz-udm-platform-equipment-model. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Augment to openconfig platform module
  """
  _pyangbind_elements = {}

  

class yc_config_openconfig_platform__components_component_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each component
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/config/name (string)

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_temperature_openconfig_platform__components_component_state_temperature(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/state/temperature. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
  """
  __slots__ = ('_path_helper', '_extmethods', '__instant','__avg','__min_','__max_','__interval','__min_time','__max_time','__alarm_status','__alarm_threshold','__alarm_severity',)

  _yang_name = 'temperature'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=True)
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)
    self.__alarm_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)
    self.__alarm_severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'state', 'temperature']

  def _get_instant(self):
    """
    Getter method for instant, mapped from YANG variable /components/component/state/temperature/instant (decimal64)

    YANG Description: The instantaneous value of the statistic.
    """
    return self.__instant
      
  def _set_instant(self, v, load=False):
    """
    Setter method for instant, mapped from YANG variable /components/component/state/temperature/instant (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instant is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instant() directly.

    YANG Description: The instantaneous value of the statistic.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """instant must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)""",
        })

    self.__instant = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_instant(self):
    self.__instant = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="instant", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)


  def _get_avg(self):
    """
    Getter method for avg, mapped from YANG variable /components/component/state/temperature/avg (decimal64)

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    return self.__avg
      
  def _set_avg(self, v, load=False):
    """
    Setter method for avg, mapped from YANG variable /components/component/state/temperature/avg (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_avg is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_avg() directly.

    YANG Description: The arithmetic mean value of the statistic over the
sampling period.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """avg must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)""",
        })

    self.__avg = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_avg(self):
    self.__avg = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="avg", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)


  def _get_min_(self):
    """
    Getter method for min_, mapped from YANG variable /components/component/state/temperature/min (decimal64)

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    return self.__min_
      
  def _set_min_(self, v, load=False):
    """
    Setter method for min_, mapped from YANG variable /components/component/state/temperature/min (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_() directly.

    YANG Description: The minimum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)""",
        })

    self.__min_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_(self):
    self.__min_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)


  def _get_max_(self):
    """
    Getter method for max_, mapped from YANG variable /components/component/state/temperature/max (decimal64)

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    return self.__max_
      
  def _set_max_(self, v, load=False):
    """
    Setter method for max_, mapped from YANG variable /components/component/state/temperature/max (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_() directly.

    YANG Description: The maximum value of the statistic over the sampling
period
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_ must be of a type compatible with decimal64""",
          'defined-type': "decimal64",
          'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)""",
        })

    self.__max_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_(self):
    self.__max_ = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=1), is_leaf=True, yang_name="max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='decimal64', is_config=True)


  def _get_interval(self):
    """
    Getter method for interval, mapped from YANG variable /components/component/state/temperature/interval (oc-types:stat-interval)

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    return self.__interval
      
  def _set_interval(self, v, load=False):
    """
    Setter method for interval, mapped from YANG variable /components/component/state/temperature/interval (oc-types:stat-interval)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interval is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interval() directly.

    YANG Description: If supported by the system, this reports the time interval
over which the min/max/average statistics are computed by
the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """interval must be of a type compatible with oc-types:stat-interval""",
          'defined-type': "oc-types:stat-interval",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=True)""",
        })

    self.__interval = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_interval(self):
    self.__interval = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="interval", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:stat-interval', is_config=True)


  def _get_min_time(self):
    """
    Getter method for min_time, mapped from YANG variable /components/component/state/temperature/min_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__min_time
      
  def _set_min_time(self, v, load=False):
    """
    Setter method for min_time, mapped from YANG variable /components/component/state/temperature/min_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_time() directly.

    YANG Description: The absolute time at which the minimum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """min_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)""",
        })

    self.__min_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_min_time(self):
    self.__min_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)


  def _get_max_time(self):
    """
    Getter method for max_time, mapped from YANG variable /components/component/state/temperature/max_time (oc-types:timeticks64)

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    return self.__max_time
      
  def _set_max_time(self, v, load=False):
    """
    Setter method for max_time, mapped from YANG variable /components/component/state/temperature/max_time (oc-types:timeticks64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_time() directly.

    YANG Description: The absolute time at which the maximum value occurred.
The value is the timestamp in nanoseconds relative to
 the Unix Epoch (Jan 1, 1970 00:00:00 UTC).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """max_time must be of a type compatible with oc-types:timeticks64""",
          'defined-type': "oc-types:timeticks64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)""",
        })

    self.__max_time = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_max_time(self):
    self.__max_time = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="max-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-types:timeticks64', is_config=True)


  def _get_alarm_status(self):
    """
    Getter method for alarm_status, mapped from YANG variable /components/component/state/temperature/alarm_status (boolean)

    YANG Description: A value of true indicates the alarm has been raised or
asserted.  The value should be false when the alarm is
cleared.
    """
    return self.__alarm_status
      
  def _set_alarm_status(self, v, load=False):
    """
    Setter method for alarm_status, mapped from YANG variable /components/component/state/temperature/alarm_status (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_status() directly.

    YANG Description: A value of true indicates the alarm has been raised or
asserted.  The value should be false when the alarm is
cleared.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_status must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)""",
        })

    self.__alarm_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_status(self):
    self.__alarm_status = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="alarm-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)


  def _get_alarm_threshold(self):
    """
    Getter method for alarm_threshold, mapped from YANG variable /components/component/state/temperature/alarm_threshold (uint32)

    YANG Description: The threshold value that was crossed for this alarm.
    """
    return self.__alarm_threshold
      
  def _set_alarm_threshold(self, v, load=False):
    """
    Setter method for alarm_threshold, mapped from YANG variable /components/component/state/temperature/alarm_threshold (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_threshold() directly.

    YANG Description: The threshold value that was crossed for this alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_threshold must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)""",
        })

    self.__alarm_threshold = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_threshold(self):
    self.__alarm_threshold = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="alarm-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)


  def _get_alarm_severity(self):
    """
    Getter method for alarm_severity, mapped from YANG variable /components/component/state/temperature/alarm_severity (identityref)

    YANG Description: The severity of the current alarm.
    """
    return self.__alarm_severity
      
  def _set_alarm_severity(self, v, load=False):
    """
    Setter method for alarm_severity, mapped from YANG variable /components/component/state/temperature/alarm_severity (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_severity() directly.

    YANG Description: The severity of the current alarm.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm_severity must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)""",
        })

    self.__alarm_severity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm_severity(self):
    self.__alarm_severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:UNKNOWN': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MINOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:WARNING': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:MAJOR': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}, 'oc-alarm-types:CRITICAL': {'@module': 'openconfig-alarm-types', '@namespace': 'http://openconfig.net/yang/alarms/types'}},), is_leaf=True, yang_name="alarm-severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)

  instant = __builtin__.property(_get_instant, _set_instant)
  avg = __builtin__.property(_get_avg, _set_avg)
  min_ = __builtin__.property(_get_min_, _set_min_)
  max_ = __builtin__.property(_get_max_, _set_max_)
  interval = __builtin__.property(_get_interval, _set_interval)
  min_time = __builtin__.property(_get_min_time, _set_min_time)
  max_time = __builtin__.property(_get_max_time, _set_max_time)
  alarm_status = __builtin__.property(_get_alarm_status, _set_alarm_status)
  alarm_threshold = __builtin__.property(_get_alarm_threshold, _set_alarm_threshold)
  alarm_severity = __builtin__.property(_get_alarm_severity, _set_alarm_severity)


  _pyangbind_elements = OrderedDict([('instant', instant), ('avg', avg), ('min_', min_), ('max_', max_), ('interval', interval), ('min_time', min_time), ('max_time', max_time), ('alarm_status', alarm_status), ('alarm_threshold', alarm_threshold), ('alarm_severity', alarm_severity), ])


class yc_memory_openconfig_platform__components_component_state_memory(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/state/memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
  """
  __slots__ = ('_path_helper', '_extmethods', '__available','__utilized',)

  _yang_name = 'memory'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__available = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)
    self.__utilized = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'state', 'memory']

  def _get_available(self):
    """
    Getter method for available, mapped from YANG variable /components/component/state/memory/available (uint64)

    YANG Description: The available memory physically installed, or logically
allocated to the component.
    """
    return self.__available
      
  def _set_available(self, v, load=False):
    """
    Setter method for available, mapped from YANG variable /components/component/state/memory/available (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_available is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_available() directly.

    YANG Description: The available memory physically installed, or logically
allocated to the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """available must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)""",
        })

    self.__available = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_available(self):
    self.__available = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="available", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)


  def _get_utilized(self):
    """
    Getter method for utilized, mapped from YANG variable /components/component/state/memory/utilized (uint64)

    YANG Description: The memory currently in use by processes running on
the component, not considering reserved memory that is
not available for use.
    """
    return self.__utilized
      
  def _set_utilized(self, v, load=False):
    """
    Setter method for utilized, mapped from YANG variable /components/component/state/memory/utilized (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_utilized is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_utilized() directly.

    YANG Description: The memory currently in use by processes running on
the component, not considering reserved memory that is
not available for use.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """utilized must be of a type compatible with uint64""",
          'defined-type': "uint64",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)""",
        })

    self.__utilized = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_utilized(self):
    self.__utilized = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="utilized", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint64', is_config=True)

  available = __builtin__.property(_get_available, _set_available)
  utilized = __builtin__.property(_get_utilized, _set_utilized)


  _pyangbind_elements = OrderedDict([('available', available), ('utilized', utilized), ])


class yc_state_openconfig_platform__components_component_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each component
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__type','__id','__location','__description','__mfg_name','__mfg_date','__hardware_version','__firmware_version','__software_version','__serial_no','__part_no','__removable','__oper_status','__empty','__parent','__temperature','__memory','__allocated_power','__used_power',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__location = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__mfg_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__mfg_date = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=True)
    self.__hardware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__firmware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__serial_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__part_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__removable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)
    self.__empty = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)
    self.__parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    self.__temperature = YANGDynClass(base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__memory = YANGDynClass(base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__allocated_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)
    self.__used_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/state/name (string)

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Device name for the component -- this may not be a
configurable parameter on many implementations.  Where
component preconfiguration is supported, for example,
the component name may be configurable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /components/component/state/type (union)

    YANG Description: Type of component as identified by the system
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /components/component/state/type (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Type of component as identified by the system
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with union""",
          'defined-type': "openconfig-platform:union",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CHASSIS': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:BACKPLANE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FABRIC': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:POWER_SUPPLY': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FAN': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:SENSOR': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:FRU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:LINECARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CONTROLLER_CARD': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:PORT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:TRANSCEIVER': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:CPU': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:STORAGE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INTEGRATED_CIRCUIT': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:OPERATING_SYSTEM': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},),], is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)


  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /components/component/state/id (string)

    YANG Description: Unique identifier assigned by the system for the
component
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /components/component/state/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier assigned by the system for the
component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_location(self):
    """
    Getter method for location, mapped from YANG variable /components/component/state/location (string)

    YANG Description: System-supplied description of the location of the
component within the system. This could be a bay position,
slot number, socket location, etc. For component types that
have an explicit slot-id attribute, such as linecards, the
system should populate the more specific slot-id.
    """
    return self.__location
      
  def _set_location(self, v, load=False):
    """
    Setter method for location, mapped from YANG variable /components/component/state/location (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_location is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_location() directly.

    YANG Description: System-supplied description of the location of the
component within the system. This could be a bay position,
slot number, socket location, etc. For component types that
have an explicit slot-id attribute, such as linecards, the
system should populate the more specific slot-id.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """location must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__location = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_location(self):
    self.__location = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="location", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/state/description (string)

    YANG Description: System-supplied description of the component
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/state/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: System-supplied description of the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_mfg_name(self):
    """
    Getter method for mfg_name, mapped from YANG variable /components/component/state/mfg_name (string)

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    return self.__mfg_name
      
  def _set_mfg_name(self, v, load=False):
    """
    Setter method for mfg_name, mapped from YANG variable /components/component/state/mfg_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_name() directly.

    YANG Description: System-supplied identifier for the manufacturer of the
component.  This data is particularly useful when a
component manufacturer is different than the overall
device vendor.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__mfg_name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_name(self):
    self.__mfg_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mfg-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_mfg_date(self):
    """
    Getter method for mfg_date, mapped from YANG variable /components/component/state/mfg_date (oc-yang:date)

    YANG Description: System-supplied representation of the component's
manufacturing date.
    """
    return self.__mfg_date
      
  def _set_mfg_date(self, v, load=False):
    """
    Setter method for mfg_date, mapped from YANG variable /components/component/state/mfg_date (oc-yang:date)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mfg_date is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mfg_date() directly.

    YANG Description: System-supplied representation of the component's
manufacturing date.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mfg_date must be of a type compatible with oc-yang:date""",
          'defined-type': "oc-yang:date",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=True)""",
        })

    self.__mfg_date = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mfg_date(self):
    self.__mfg_date = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '^[0-9]{4}\\-[0-9]{2}\\-[0-9]{2}$'}), is_leaf=True, yang_name="mfg-date", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='oc-yang:date', is_config=True)


  def _get_hardware_version(self):
    """
    Getter method for hardware_version, mapped from YANG variable /components/component/state/hardware_version (string)

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    return self.__hardware_version
      
  def _set_hardware_version(self, v, load=False):
    """
    Setter method for hardware_version, mapped from YANG variable /components/component/state/hardware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hardware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hardware_version() directly.

    YANG Description: For hardware components, this is the hardware revision of
the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """hardware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__hardware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_hardware_version(self):
    self.__hardware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hardware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_firmware_version(self):
    """
    Getter method for firmware_version, mapped from YANG variable /components/component/state/firmware_version (string)

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    return self.__firmware_version
      
  def _set_firmware_version(self, v, load=False):
    """
    Setter method for firmware_version, mapped from YANG variable /components/component/state/firmware_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firmware_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firmware_version() directly.

    YANG Description: For hardware components, this is the version of associated
firmware that is running on the component, if applicable.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firmware_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__firmware_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firmware_version(self):
    self.__firmware_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firmware-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_software_version(self):
    """
    Getter method for software_version, mapped from YANG variable /components/component/state/software_version (string)

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    return self.__software_version
      
  def _set_software_version(self, v, load=False):
    """
    Setter method for software_version, mapped from YANG variable /components/component/state/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: For software components such as operating system or other
software module, this is the version of the currently
running software.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """software_version must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__software_version = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_software_version(self):
    self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_serial_no(self):
    """
    Getter method for serial_no, mapped from YANG variable /components/component/state/serial_no (string)

    YANG Description: System-assigned serial number of the component.
    """
    return self.__serial_no
      
  def _set_serial_no(self, v, load=False):
    """
    Setter method for serial_no, mapped from YANG variable /components/component/state/serial_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serial_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serial_no() directly.

    YANG Description: System-assigned serial number of the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serial_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__serial_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serial_no(self):
    self.__serial_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serial-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_part_no(self):
    """
    Getter method for part_no, mapped from YANG variable /components/component/state/part_no (string)

    YANG Description: System-assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    return self.__part_no
      
  def _set_part_no(self, v, load=False):
    """
    Setter method for part_no, mapped from YANG variable /components/component/state/part_no (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_part_no is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_part_no() directly.

    YANG Description: System-assigned part number for the component.  This should
be present in particular if the component is also an FRU
(field replaceable unit)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """part_no must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__part_no = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_part_no(self):
    self.__part_no = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="part-no", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_removable(self):
    """
    Getter method for removable, mapped from YANG variable /components/component/state/removable (boolean)

    YANG Description: If true, this component is removable or is a field
replaceable unit
    """
    return self.__removable
      
  def _set_removable(self, v, load=False):
    """
    Setter method for removable, mapped from YANG variable /components/component/state/removable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_removable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_removable() directly.

    YANG Description: If true, this component is removable or is a field
replaceable unit
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """removable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)""",
        })

    self.__removable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_removable(self):
    self.__removable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="removable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)


  def _get_oper_status(self):
    """
    Getter method for oper_status, mapped from YANG variable /components/component/state/oper_status (identityref)

    YANG Description: If applicable, this reports the current operational status
of the component.
    """
    return self.__oper_status
      
  def _set_oper_status(self, v, load=False):
    """
    Setter method for oper_status, mapped from YANG variable /components/component/state/oper_status (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oper_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oper_status() directly.

    YANG Description: If applicable, this reports the current operational status
of the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """oper_status must be of a type compatible with identityref""",
          'defined-type': "openconfig-platform:identityref",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)""",
        })

    self.__oper_status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_oper_status(self):
    self.__oper_status = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:ACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:INACTIVE': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}, 'oc-platform-types:DISABLED': {'@module': 'openconfig-platform-types', '@namespace': 'http://openconfig.net/yang/platform-types'}},), is_leaf=True, yang_name="oper-status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='identityref', is_config=True)


  def _get_empty(self):
    """
    Getter method for empty, mapped from YANG variable /components/component/state/empty (boolean)

    YANG Description: The empty leaf may be used by the device to indicate that a
component position exists but is not populated.  Using this
flag, it is possible for the management system to learn how
many positions are available (e.g., occupied vs. empty
linecard slots in a chassis).
    """
    return self.__empty
      
  def _set_empty(self, v, load=False):
    """
    Setter method for empty, mapped from YANG variable /components/component/state/empty (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_empty is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_empty() directly.

    YANG Description: The empty leaf may be used by the device to indicate that a
component position exists but is not populated.  Using this
flag, it is possible for the management system to learn how
many positions are available (e.g., occupied vs. empty
linecard slots in a chassis).
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """empty must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)""",
        })

    self.__empty = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_empty(self):
    self.__empty = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="empty", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=True)


  def _get_parent(self):
    """
    Getter method for parent, mapped from YANG variable /components/component/state/parent (leafref)

    YANG Description: Reference to the name of the parent component.  Note that
this reference must be kept synchronized with the
corresponding subcomponent reference from the parent
component.
    """
    return self.__parent
      
  def _set_parent(self, v, load=False):
    """
    Setter method for parent, mapped from YANG variable /components/component/state/parent (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent() directly.

    YANG Description: Reference to the name of the parent component.  Note that
this reference must be kept synchronized with the
corresponding subcomponent reference from the parent
component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__parent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent(self):
    self.__parent = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)


  def _get_temperature(self):
    """
    Getter method for temperature, mapped from YANG variable /components/component/state/temperature (container)

    YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
    """
    return self.__temperature
      
  def _set_temperature(self, v, load=False):
    """
    Setter method for temperature, mapped from YANG variable /components/component/state/temperature (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_temperature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_temperature() directly.

    YANG Description: Temperature in degrees Celsius of the component. Values include
the instantaneous, average, minimum, and maximum statistics. If
avg/min/max statistics are not supported, the target is expected
to just supply the instant value
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """temperature must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__temperature = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_temperature(self):
    self.__temperature = YANGDynClass(base=yc_temperature_openconfig_platform__components_component_state_temperature, is_container='container', yang_name="temperature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_memory(self):
    """
    Getter method for memory, mapped from YANG variable /components/component/state/memory (container)

    YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
    """
    return self.__memory
      
  def _set_memory(self, v, load=False):
    """
    Setter method for memory, mapped from YANG variable /components/component/state/memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory() directly.

    YANG Description: For components that have associated memory, these values
report information about available and utilized memory.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """memory must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__memory = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_memory(self):
    self.__memory = YANGDynClass(base=yc_memory_openconfig_platform__components_component_state_memory, is_container='container', yang_name="memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_allocated_power(self):
    """
    Getter method for allocated_power, mapped from YANG variable /components/component/state/allocated_power (uint32)

    YANG Description: Power allocated by the system for the component.
    """
    return self.__allocated_power
      
  def _set_allocated_power(self, v, load=False):
    """
    Setter method for allocated_power, mapped from YANG variable /components/component/state/allocated_power (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_allocated_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_allocated_power() directly.

    YANG Description: Power allocated by the system for the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """allocated_power must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)""",
        })

    self.__allocated_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_allocated_power(self):
    self.__allocated_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="allocated-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)


  def _get_used_power(self):
    """
    Getter method for used_power, mapped from YANG variable /components/component/state/used_power (uint32)

    YANG Description: Actual power used by the component.
    """
    return self.__used_power
      
  def _set_used_power(self, v, load=False):
    """
    Setter method for used_power, mapped from YANG variable /components/component/state/used_power (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_used_power is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_used_power() directly.

    YANG Description: Actual power used by the component.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """used_power must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)""",
        })

    self.__used_power = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_used_power(self):
    self.__used_power = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="used-power", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='uint32', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  type = __builtin__.property(_get_type, _set_type)
  id = __builtin__.property(_get_id, _set_id)
  location = __builtin__.property(_get_location, _set_location)
  description = __builtin__.property(_get_description, _set_description)
  mfg_name = __builtin__.property(_get_mfg_name, _set_mfg_name)
  mfg_date = __builtin__.property(_get_mfg_date, _set_mfg_date)
  hardware_version = __builtin__.property(_get_hardware_version, _set_hardware_version)
  firmware_version = __builtin__.property(_get_firmware_version, _set_firmware_version)
  software_version = __builtin__.property(_get_software_version, _set_software_version)
  serial_no = __builtin__.property(_get_serial_no, _set_serial_no)
  part_no = __builtin__.property(_get_part_no, _set_part_no)
  removable = __builtin__.property(_get_removable, _set_removable)
  oper_status = __builtin__.property(_get_oper_status, _set_oper_status)
  empty = __builtin__.property(_get_empty, _set_empty)
  parent = __builtin__.property(_get_parent, _set_parent)
  temperature = __builtin__.property(_get_temperature, _set_temperature)
  memory = __builtin__.property(_get_memory, _set_memory)
  allocated_power = __builtin__.property(_get_allocated_power, _set_allocated_power)
  used_power = __builtin__.property(_get_used_power, _set_used_power)


  _pyangbind_elements = OrderedDict([('name', name), ('type', type), ('id', id), ('location', location), ('description', description), ('mfg_name', mfg_name), ('mfg_date', mfg_date), ('hardware_version', hardware_version), ('firmware_version', firmware_version), ('software_version', software_version), ('serial_no', serial_no), ('part_no', part_no), ('removable', removable), ('oper_status', oper_status), ('empty', empty), ('parent', parent), ('temperature', temperature), ('memory', memory), ('allocated_power', allocated_power), ('used_power', used_power), ])


class yc_config_openconfig_platform__components_component_properties_property_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties/property/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for each property
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__value',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'properties', 'property', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/properties/property/config/name (string)

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/properties/property/config/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=True)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /components/component/properties/property/config/value (union)

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /components/component/properties/property/config/value (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with union""",
          'defined-type': "openconfig-platform:union",
          'generated-type': """YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  value = __builtin__.property(_get_value, _set_value)


  _pyangbind_elements = OrderedDict([('name', name), ('value', value), ])


class yc_state_openconfig_platform__components_component_properties_property_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties/property/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for each property
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__value','__configurable',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    self.__configurable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'properties', 'property', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/properties/property/state/name (string)

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/properties/property/state/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: System-supplied name of the property -- this is typically
non-configurable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='string', is_config=False)


  def _get_value(self):
    """
    Getter method for value, mapped from YANG variable /components/component/properties/property/state/value (union)

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    return self.__value
      
  def _set_value(self, v, load=False):
    """
    Setter method for value, mapped from YANG variable /components/component/properties/property/state/value (union)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Property values can take on a variety of types.  Signed and
unsigned integer types may be provided in smaller sizes,
e.g., int8, uint16, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """value must be of a type compatible with union""",
          'defined-type': "openconfig-platform:union",
          'generated-type': """YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)""",
        })

    self.__value = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_value(self):
    self.__value = YANGDynClass(base=[six.text_type,YANGBool,RestrictedClassType(base_type=long, restriction_dict={'range': ['-9223372036854775808..9223372036854775807']}, int_size=64),RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64),RestrictedPrecisionDecimalType(precision=2),], is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='union', is_config=False)


  def _get_configurable(self):
    """
    Getter method for configurable, mapped from YANG variable /components/component/properties/property/state/configurable (boolean)

    YANG Description: Indication whether the property is user-configurable
    """
    return self.__configurable
      
  def _set_configurable(self, v, load=False):
    """
    Setter method for configurable, mapped from YANG variable /components/component/properties/property/state/configurable (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configurable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configurable() directly.

    YANG Description: Indication whether the property is user-configurable
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """configurable must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)""",
        })

    self.__configurable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_configurable(self):
    self.__configurable = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="configurable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='boolean', is_config=False)

  name = __builtin__.property(_get_name)
  value = __builtin__.property(_get_value)
  configurable = __builtin__.property(_get_configurable)


  _pyangbind_elements = OrderedDict([('name', name), ('value', value), ('configurable', configurable), ])


class yc_property__openconfig_platform__components_component_properties_property(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties/property. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of system properties for the component
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state',)

  _yang_name = 'property'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'properties', 'property']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/properties/property/name (leafref)

    YANG Description: Reference to the property name.
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/properties/property/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the property name.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/properties/property/config (container)

    YANG Description: Configuration data for each property
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/properties/property/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each property
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_properties_property_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/properties/property/state (container)

    YANG Description: Operational state data for each property
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/properties/property/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each property
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_properties_property_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ])


class yc_properties_openconfig_platform__components_component_properties(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container 
  """
  __slots__ = ('_path_helper', '_extmethods', '__property_',)

  _yang_name = 'properties'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__property_ = YANGDynClass(base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'properties']

  def _get_property_(self):
    """
    Getter method for property_, mapped from YANG variable /components/component/properties/property (list)

    YANG Description: List of system properties for the component
    """
    return self.__property_
      
  def _set_property_(self, v, load=False):
    """
    Setter method for property_, mapped from YANG variable /components/component/properties/property (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_property_ is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_property_() directly.

    YANG Description: List of system properties for the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """property_ must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)""",
        })

    self.__property_ = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_property_(self):
    self.__property_ = YANGDynClass(base=YANGListType("name",yc_property__openconfig_platform__components_component_properties_property, yang_name="property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

  property_ = __builtin__.property(_get_property_, _set_property_)


  _pyangbind_elements = OrderedDict([('property_', property_), ])


class yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents/subcomponent/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration data for the subcomponent
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'config'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'subcomponents', 'subcomponent', 'config']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/config/name (leafref)

    YANG Description: Reference to the name of the subcomponent
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/config/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name of the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents/subcomponent/state. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Operational state data for the subcomponent
  """
  __slots__ = ('_path_helper', '_extmethods', '__name',)

  _yang_name = 'state'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'subcomponents', 'subcomponent', 'state']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/state/name (leafref)

    YANG Description: Reference to the name of the subcomponent
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/state/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name of the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=False)

  name = __builtin__.property(_get_name)


  _pyangbind_elements = OrderedDict([('name', name), ])


class yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents/subcomponent. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of subcomponent references
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state',)

  _yang_name = 'subcomponent'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'subcomponents', 'subcomponent']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/name (leafref)

    YANG Description: Reference to the name list key
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/subcomponents/subcomponent/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Reference to the name list key
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/subcomponents/subcomponent/config (container)

    YANG Description: Configuration data for the subcomponent
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/subcomponents/subcomponent/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_subcomponents_subcomponent_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/subcomponents/subcomponent/state (container)

    YANG Description: Operational state data for the subcomponent
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/subcomponents/subcomponent/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for the subcomponent
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_subcomponents_subcomponent_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ])


class yc_subcomponents_openconfig_platform__components_component_subcomponents(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/subcomponents. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for subcomponent references
  """
  __slots__ = ('_path_helper', '_extmethods', '__subcomponent',)

  _yang_name = 'subcomponents'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__subcomponent = YANGDynClass(base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'subcomponents']

  def _get_subcomponent(self):
    """
    Getter method for subcomponent, mapped from YANG variable /components/component/subcomponents/subcomponent (list)

    YANG Description: List of subcomponent references
    """
    return self.__subcomponent
      
  def _set_subcomponent(self, v, load=False):
    """
    Setter method for subcomponent, mapped from YANG variable /components/component/subcomponents/subcomponent (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subcomponent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subcomponent() directly.

    YANG Description: List of subcomponent references
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subcomponent must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)""",
        })

    self.__subcomponent = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subcomponent(self):
    self.__subcomponent = YANGDynClass(base=YANGListType("name",yc_subcomponent_openconfig_platform__components_component_subcomponents_subcomponent, yang_name="subcomponent", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="subcomponent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

  subcomponent = __builtin__.property(_get_subcomponent, _set_subcomponent)


  _pyangbind_elements = OrderedDict([('subcomponent', subcomponent), ])


class yc_chassis_openconfig_platform__components_component_chassis(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/chassis. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for chassis components
  """
  _pyangbind_elements = {}

  

class yc_port_openconfig_platform__components_component_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for physical port components
  """
  _pyangbind_elements = {}

  

class yc_power_supply_openconfig_platform__components_component_power_supply(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/power-supply. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for power supply components
  """
  _pyangbind_elements = {}

  

class yc_fan_openconfig_platform__components_component_fan(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/fan. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for fan components
  """
  _pyangbind_elements = {}

  

class yc_fabric_openconfig_platform__components_component_fabric(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/fabric. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for fabric components
  """
  _pyangbind_elements = {}

  

class yc_storage_openconfig_platform__components_component_storage(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/storage. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for storage components
  """
  _pyangbind_elements = {}

  

class yc_cpu_openconfig_platform__components_component_cpu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for cpu components
  """
  _pyangbind_elements = {}

  

class yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/integrated-circuit. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for chip components, such as ASIC, NPUs, etc.
  """
  _pyangbind_elements = {}

  

class yc_backplane_openconfig_platform__components_component_backplane(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/backplane. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Data for backplane components
  """
  _pyangbind_elements = {}

  

class yc_component_openconfig_platform__components_component_holder_slots_slot_component(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/holder/slots/slot/component. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of components in this slots
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__component','__subslot','__subslotname',)

  _yang_name = 'component'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    self.__component = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='leafref', is_config=True)
    self.__subslot = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subslot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    self.__subslotname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'holder', 'slots', 'slot', 'component']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/holder/slots/slot/component/name (string)

    YANG Description: name of component
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/holder/slots/slot/component/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: name of component
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)


  def _get_component(self):
    """
    Getter method for component, mapped from YANG variable /components/component/holder/slots/slot/component/component (leafref)
    """
    return self.__component
      
  def _set_component(self, v, load=False):
    """
    Setter method for component, mapped from YANG variable /components/component/holder/slots/slot/component/component (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='leafref', is_config=True)""",
        })

    self.__component = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component(self):
    self.__component = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='leafref', is_config=True)


  def _get_subslot(self):
    """
    Getter method for subslot, mapped from YANG variable /components/component/holder/slots/slot/component/subslot (string)

    YANG Description: subslot
    """
    return self.__subslot
      
  def _set_subslot(self, v, load=False):
    """
    Setter method for subslot, mapped from YANG variable /components/component/holder/slots/slot/component/subslot (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subslot is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subslot() directly.

    YANG Description: subslot
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subslot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subslot must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subslot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)""",
        })

    self.__subslot = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subslot(self):
    self.__subslot = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subslot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)


  def _get_subslotname(self):
    """
    Getter method for subslotname, mapped from YANG variable /components/component/holder/slots/slot/component/subslotname (string)

    YANG Description: subslot Name
    """
    return self.__subslotname
      
  def _set_subslotname(self, v, load=False):
    """
    Setter method for subslotname, mapped from YANG variable /components/component/holder/slots/slot/component/subslotname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subslotname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subslotname() directly.

    YANG Description: subslot Name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subslotname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)""",
        })

    self.__subslotname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subslotname(self):
    self.__subslotname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  component = __builtin__.property(_get_component, _set_component)
  subslot = __builtin__.property(_get_subslot, _set_subslot)
  subslotname = __builtin__.property(_get_subslotname, _set_subslotname)


  _pyangbind_elements = OrderedDict([('name', name), ('component', component), ('subslot', subslot), ('subslotname', subslotname), ])


class yc_slot_openconfig_platform__components_component_holder_slots_slot(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/holder/slots/slot. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of slots
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__slotnumber','__component',)

  _yang_name = 'slot'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    self.__slotnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    self.__component = YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component_holder_slots_slot_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'holder', 'slots', 'slot']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/holder/slots/slot/name (string)

    YANG Description: Slot identifier
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/holder/slots/slot/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Slot identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)


  def _get_slotnumber(self):
    """
    Getter method for slotnumber, mapped from YANG variable /components/component/holder/slots/slot/slotnumber (string)

    YANG Description: Slot Number
    """
    return self.__slotnumber
      
  def _set_slotnumber(self, v, load=False):
    """
    Setter method for slotnumber, mapped from YANG variable /components/component/holder/slots/slot/slotnumber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slotnumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slotnumber() directly.

    YANG Description: Slot Number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slotnumber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)""",
        })

    self.__slotnumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slotnumber(self):
    self.__slotnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='string', is_config=True)


  def _get_component(self):
    """
    Getter method for component, mapped from YANG variable /components/component/holder/slots/slot/component (list)

    YANG Description: List of components in this slots
    """
    return self.__component
      
  def _set_component(self, v, load=False):
    """
    Setter method for component, mapped from YANG variable /components/component/holder/slots/slot/component (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component() directly.

    YANG Description: List of components in this slots
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_component_openconfig_platform__components_component_holder_slots_slot_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component_holder_slots_slot_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)""",
        })

    self.__component = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component(self):
    self.__component = YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component_holder_slots_slot_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  slotnumber = __builtin__.property(_get_slotnumber, _set_slotnumber)
  component = __builtin__.property(_get_component, _set_component)


  _pyangbind_elements = OrderedDict([('name', name), ('slotnumber', slotnumber), ('component', component), ])


class yc_slots_openconfig_platform__components_component_holder_slots(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/holder/slots. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Slots on the component
  """
  __slots__ = ('_path_helper', '_extmethods', '__slot',)

  _yang_name = 'slots'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slot = YANGDynClass(base=YANGListType("name",yc_slot_openconfig_platform__components_component_holder_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'holder', 'slots']

  def _get_slot(self):
    """
    Getter method for slot, mapped from YANG variable /components/component/holder/slots/slot (list)

    YANG Description: List of slots
    """
    return self.__slot
      
  def _set_slot(self, v, load=False):
    """
    Setter method for slot, mapped from YANG variable /components/component/holder/slots/slot (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot() directly.

    YANG Description: List of slots
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_slot_openconfig_platform__components_component_holder_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_slot_openconfig_platform__components_component_holder_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)""",
        })

    self.__slot = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot(self):
    self.__slot = YANGDynClass(base=YANGListType("name",yc_slot_openconfig_platform__components_component_holder_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='list', is_config=True)

  slot = __builtin__.property(_get_slot, _set_slot)


  _pyangbind_elements = OrderedDict([('slot', slot), ])


class yc_holder_openconfig_platform__components_component_holder(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/holder. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__slots',)

  _yang_name = 'holder'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slots = YANGDynClass(base=yc_slots_openconfig_platform__components_component_holder_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'holder']

  def _get_slots(self):
    """
    Getter method for slots, mapped from YANG variable /components/component/holder/slots (container)

    YANG Description: Slots on the component
    """
    return self.__slots
      
  def _set_slots(self, v, load=False):
    """
    Setter method for slots, mapped from YANG variable /components/component/holder/slots (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slots is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slots() directly.

    YANG Description: Slots on the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_slots_openconfig_platform__components_component_holder_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slots must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_slots_openconfig_platform__components_component_holder_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)""",
        })

    self.__slots = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slots(self):
    self.__slots = YANGDynClass(base=yc_slots_openconfig_platform__components_component_holder_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)

  slots = __builtin__.property(_get_slots, _set_slots)


  _pyangbind_elements = OrderedDict([('slots', slots), ])


class yc_cards_openconfig_platform__components_component_model_slots_slot_cards(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/model/slots/slot/cards. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of cards supported in this slots
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__card',)

  _yang_name = 'cards'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__card = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="card", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'model', 'slots', 'slot', 'cards']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/model/slots/slot/cards/name (string)

    YANG Description: name of card
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/model/slots/slot/cards/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: name of card
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_card(self):
    """
    Getter method for card, mapped from YANG variable /components/component/model/slots/slot/cards/card (leafref)
    """
    return self.__card
      
  def _set_card(self, v, load=False):
    """
    Setter method for card, mapped from YANG variable /components/component/model/slots/slot/cards/card (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_card is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_card() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="card", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """card must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="card", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='leafref', is_config=True)""",
        })

    self.__card = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_card(self):
    self.__card = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="card", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  card = __builtin__.property(_get_card, _set_card)


  _pyangbind_elements = OrderedDict([('name', name), ('card', card), ])


class yc_slot_openconfig_platform__components_component_model_slots_slot(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/model/slots/slot. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of slots
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__logicalslotname','__slotnumber','__barcodeslotposition','__side','__orientation','__description','__purpose','__weight','__height','__width','__depth','__dimtobase','__dimtoleft','__dimtofront','__dimtotop','__subclass','__trafficBearing','__cards',)

  _yang_name = 'slot'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__logicalslotname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logicalslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__slotnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__barcodeslotposition = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="barcodeslotposition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__side = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__orientation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="orientation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__purpose = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__weight = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__height = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__width = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__depth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtobase = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtoleft = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtofront = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtotop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__subclass = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__trafficBearing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__cards = YANGDynClass(base=YANGListType("name",yc_cards_openconfig_platform__components_component_model_slots_slot_cards, yang_name="cards", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="cards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'model', 'slots', 'slot']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/model/slots/slot/name (string)

    YANG Description: Slot identifier
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/model/slots/slot/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Slot identifier
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_logicalslotname(self):
    """
    Getter method for logicalslotname, mapped from YANG variable /components/component/model/slots/slot/logicalslotname (string)

    YANG Description: Logical Slot Name (EMS/CLI)
    """
    return self.__logicalslotname
      
  def _set_logicalslotname(self, v, load=False):
    """
    Setter method for logicalslotname, mapped from YANG variable /components/component/model/slots/slot/logicalslotname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logicalslotname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logicalslotname() directly.

    YANG Description: Logical Slot Name (EMS/CLI)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="logicalslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """logicalslotname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logicalslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__logicalslotname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_logicalslotname(self):
    self.__logicalslotname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="logicalslotname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_slotnumber(self):
    """
    Getter method for slotnumber, mapped from YANG variable /components/component/model/slots/slot/slotnumber (string)

    YANG Description: Slot Number
    """
    return self.__slotnumber
      
  def _set_slotnumber(self, v, load=False):
    """
    Setter method for slotnumber, mapped from YANG variable /components/component/model/slots/slot/slotnumber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slotnumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slotnumber() directly.

    YANG Description: Slot Number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slotnumber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__slotnumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slotnumber(self):
    self.__slotnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="slotnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_barcodeslotposition(self):
    """
    Getter method for barcodeslotposition, mapped from YANG variable /components/component/model/slots/slot/barcodeslotposition (string)

    YANG Description: Bar Code Slot Position
    """
    return self.__barcodeslotposition
      
  def _set_barcodeslotposition(self, v, load=False):
    """
    Setter method for barcodeslotposition, mapped from YANG variable /components/component/model/slots/slot/barcodeslotposition (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_barcodeslotposition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_barcodeslotposition() directly.

    YANG Description: Bar Code Slot Position
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="barcodeslotposition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """barcodeslotposition must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="barcodeslotposition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__barcodeslotposition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_barcodeslotposition(self):
    self.__barcodeslotposition = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="barcodeslotposition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_side(self):
    """
    Getter method for side, mapped from YANG variable /components/component/model/slots/slot/side (string)

    YANG Description: Front/Rear
    """
    return self.__side
      
  def _set_side(self, v, load=False):
    """
    Setter method for side, mapped from YANG variable /components/component/model/slots/slot/side (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_side is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_side() directly.

    YANG Description: Front/Rear
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """side must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__side = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_side(self):
    self.__side = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_orientation(self):
    """
    Getter method for orientation, mapped from YANG variable /components/component/model/slots/slot/orientation (string)

    YANG Description: Slot Orientation (Veritial/Horizontal/Inverted)
    """
    return self.__orientation
      
  def _set_orientation(self, v, load=False):
    """
    Setter method for orientation, mapped from YANG variable /components/component/model/slots/slot/orientation (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_orientation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_orientation() directly.

    YANG Description: Slot Orientation (Veritial/Horizontal/Inverted)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="orientation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """orientation must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="orientation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__orientation = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_orientation(self):
    self.__orientation = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="orientation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/model/slots/slot/description (string)

    YANG Description: Description of Slot
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/model/slots/slot/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of Slot
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_purpose(self):
    """
    Getter method for purpose, mapped from YANG variable /components/component/model/slots/slot/purpose (string)

    YANG Description: Purpose of Slot
    """
    return self.__purpose
      
  def _set_purpose(self, v, load=False):
    """
    Setter method for purpose, mapped from YANG variable /components/component/model/slots/slot/purpose (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_purpose is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_purpose() directly.

    YANG Description: Purpose of Slot
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """purpose must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__purpose = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_purpose(self):
    self.__purpose = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="purpose", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /components/component/model/slots/slot/weight (string)

    YANG Description: Weight
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /components/component/model/slots/slot/weight (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: Weight
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_height(self):
    """
    Getter method for height, mapped from YANG variable /components/component/model/slots/slot/height (string)

    YANG Description: Height
    """
    return self.__height
      
  def _set_height(self, v, load=False):
    """
    Setter method for height, mapped from YANG variable /components/component/model/slots/slot/height (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_height is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_height() directly.

    YANG Description: Height
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """height must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__height = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_height(self):
    self.__height = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_width(self):
    """
    Getter method for width, mapped from YANG variable /components/component/model/slots/slot/width (string)

    YANG Description: Width
    """
    return self.__width
      
  def _set_width(self, v, load=False):
    """
    Setter method for width, mapped from YANG variable /components/component/model/slots/slot/width (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_width is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_width() directly.

    YANG Description: Width
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """width must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__width = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_width(self):
    self.__width = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_depth(self):
    """
    Getter method for depth, mapped from YANG variable /components/component/model/slots/slot/depth (string)

    YANG Description: Depth
    """
    return self.__depth
      
  def _set_depth(self, v, load=False):
    """
    Setter method for depth, mapped from YANG variable /components/component/model/slots/slot/depth (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_depth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_depth() directly.

    YANG Description: Depth
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """depth must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__depth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_depth(self):
    self.__depth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtobase(self):
    """
    Getter method for dimtobase, mapped from YANG variable /components/component/model/slots/slot/dimtobase (string)

    YANG Description: Dim to Base
    """
    return self.__dimtobase
      
  def _set_dimtobase(self, v, load=False):
    """
    Setter method for dimtobase, mapped from YANG variable /components/component/model/slots/slot/dimtobase (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtobase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtobase() directly.

    YANG Description: Dim to Base
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtobase must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtobase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtobase(self):
    self.__dimtobase = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtoleft(self):
    """
    Getter method for dimtoleft, mapped from YANG variable /components/component/model/slots/slot/dimtoleft (string)

    YANG Description: Dim to Left
    """
    return self.__dimtoleft
      
  def _set_dimtoleft(self, v, load=False):
    """
    Setter method for dimtoleft, mapped from YANG variable /components/component/model/slots/slot/dimtoleft (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtoleft is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtoleft() directly.

    YANG Description: Dim to Left
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtoleft must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtoleft = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtoleft(self):
    self.__dimtoleft = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtofront(self):
    """
    Getter method for dimtofront, mapped from YANG variable /components/component/model/slots/slot/dimtofront (string)

    YANG Description: Dim to Front
    """
    return self.__dimtofront
      
  def _set_dimtofront(self, v, load=False):
    """
    Setter method for dimtofront, mapped from YANG variable /components/component/model/slots/slot/dimtofront (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtofront is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtofront() directly.

    YANG Description: Dim to Front
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtofront must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtofront = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtofront(self):
    self.__dimtofront = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtotop(self):
    """
    Getter method for dimtotop, mapped from YANG variable /components/component/model/slots/slot/dimtotop (string)

    YANG Description: Dim to Top
    """
    return self.__dimtotop
      
  def _set_dimtotop(self, v, load=False):
    """
    Setter method for dimtotop, mapped from YANG variable /components/component/model/slots/slot/dimtotop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtotop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtotop() directly.

    YANG Description: Dim to Top
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtotop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtotop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtotop(self):
    self.__dimtotop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_subclass(self):
    """
    Getter method for subclass, mapped from YANG variable /components/component/model/slots/slot/subclass (string)

    YANG Description: Subclass
    """
    return self.__subclass
      
  def _set_subclass(self, v, load=False):
    """
    Setter method for subclass, mapped from YANG variable /components/component/model/slots/slot/subclass (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subclass is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subclass() directly.

    YANG Description: Subclass
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subclass must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__subclass = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subclass(self):
    self.__subclass = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_trafficBearing(self):
    """
    Getter method for trafficBearing, mapped from YANG variable /components/component/model/slots/slot/trafficBearing (string)

    YANG Description: Traffic Bearing (Y/N)
    """
    return self.__trafficBearing
      
  def _set_trafficBearing(self, v, load=False):
    """
    Setter method for trafficBearing, mapped from YANG variable /components/component/model/slots/slot/trafficBearing (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficBearing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficBearing() directly.

    YANG Description: Traffic Bearing (Y/N)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficBearing must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__trafficBearing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficBearing(self):
    self.__trafficBearing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_cards(self):
    """
    Getter method for cards, mapped from YANG variable /components/component/model/slots/slot/cards (list)

    YANG Description: List of cards supported in this slots
    """
    return self.__cards
      
  def _set_cards(self, v, load=False):
    """
    Setter method for cards, mapped from YANG variable /components/component/model/slots/slot/cards (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cards is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cards() directly.

    YANG Description: List of cards supported in this slots
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_cards_openconfig_platform__components_component_model_slots_slot_cards, yang_name="cards", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="cards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cards must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_cards_openconfig_platform__components_component_model_slots_slot_cards, yang_name="cards", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="cards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)""",
        })

    self.__cards = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cards(self):
    self.__cards = YANGDynClass(base=YANGListType("name",yc_cards_openconfig_platform__components_component_model_slots_slot_cards, yang_name="cards", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="cards", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  logicalslotname = __builtin__.property(_get_logicalslotname, _set_logicalslotname)
  slotnumber = __builtin__.property(_get_slotnumber, _set_slotnumber)
  barcodeslotposition = __builtin__.property(_get_barcodeslotposition, _set_barcodeslotposition)
  side = __builtin__.property(_get_side, _set_side)
  orientation = __builtin__.property(_get_orientation, _set_orientation)
  description = __builtin__.property(_get_description, _set_description)
  purpose = __builtin__.property(_get_purpose, _set_purpose)
  weight = __builtin__.property(_get_weight, _set_weight)
  height = __builtin__.property(_get_height, _set_height)
  width = __builtin__.property(_get_width, _set_width)
  depth = __builtin__.property(_get_depth, _set_depth)
  dimtobase = __builtin__.property(_get_dimtobase, _set_dimtobase)
  dimtoleft = __builtin__.property(_get_dimtoleft, _set_dimtoleft)
  dimtofront = __builtin__.property(_get_dimtofront, _set_dimtofront)
  dimtotop = __builtin__.property(_get_dimtotop, _set_dimtotop)
  subclass = __builtin__.property(_get_subclass, _set_subclass)
  trafficBearing = __builtin__.property(_get_trafficBearing, _set_trafficBearing)
  cards = __builtin__.property(_get_cards, _set_cards)


  _pyangbind_elements = OrderedDict([('name', name), ('logicalslotname', logicalslotname), ('slotnumber', slotnumber), ('barcodeslotposition', barcodeslotposition), ('side', side), ('orientation', orientation), ('description', description), ('purpose', purpose), ('weight', weight), ('height', height), ('width', width), ('depth', depth), ('dimtobase', dimtobase), ('dimtoleft', dimtoleft), ('dimtofront', dimtofront), ('dimtotop', dimtotop), ('subclass', subclass), ('trafficBearing', trafficBearing), ('cards', cards), ])


class yc_slots_openconfig_platform__components_component_model_slots(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/model/slots. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Slots on the component
  """
  __slots__ = ('_path_helper', '_extmethods', '__slot',)

  _yang_name = 'slots'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__slot = YANGDynClass(base=YANGListType("name",yc_slot_openconfig_platform__components_component_model_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'model', 'slots']

  def _get_slot(self):
    """
    Getter method for slot, mapped from YANG variable /components/component/model/slots/slot (list)

    YANG Description: List of slots
    """
    return self.__slot
      
  def _set_slot(self, v, load=False):
    """
    Setter method for slot, mapped from YANG variable /components/component/model/slots/slot (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slot is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slot() directly.

    YANG Description: List of slots
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_slot_openconfig_platform__components_component_model_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slot must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_slot_openconfig_platform__components_component_model_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)""",
        })

    self.__slot = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slot(self):
    self.__slot = YANGDynClass(base=YANGListType("name",yc_slot_openconfig_platform__components_component_model_slots_slot, yang_name="slot", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="slot", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)

  slot = __builtin__.property(_get_slot, _set_slot)


  _pyangbind_elements = OrderedDict([('slot', slot), ])


class yc_port_openconfig_platform__components_component_model_ports_port(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/model/ports/port. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of ports
  """
  __slots__ = ('_path_helper', '_extmethods', '__physicalportname','__portnameonems','__portnumber','__side','__connector','__tptype','__bandwidth','__digitalwrap','__channelization','__status','__relationtype','__relatedport','__parentportname','__dualconnname','__dualconnindicator','__direction','__description','__aid','__formula','__weight','__height','__width','__depth','__dimtobase','__dimtoleft','__dimtofront','__dimtotop','__subclass','__trafficBearing',)

  _yang_name = 'port'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__physicalportname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physicalportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__portnameonems = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="portnameonems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__portnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="portnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__side = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__connector = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__tptype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tptype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__bandwidth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__digitalwrap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="digitalwrap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__channelization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channelization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__relationtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relationtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__relatedport = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relatedport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__parentportname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parentportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dualconnname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dualconnname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dualconnindicator = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dualconnindicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__direction = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__aid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__formula = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="formula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__weight = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__height = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__width = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__depth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtobase = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtoleft = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtofront = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtotop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__subclass = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__trafficBearing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'model', 'ports', 'port']

  def _get_physicalportname(self):
    """
    Getter method for physicalportname, mapped from YANG variable /components/component/model/ports/port/physicalportname (string)

    YANG Description: Physical Port name on NE
    """
    return self.__physicalportname
      
  def _set_physicalportname(self, v, load=False):
    """
    Setter method for physicalportname, mapped from YANG variable /components/component/model/ports/port/physicalportname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physicalportname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physicalportname() directly.

    YANG Description: Physical Port name on NE
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="physicalportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """physicalportname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physicalportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__physicalportname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_physicalportname(self):
    self.__physicalportname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physicalportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_portnameonems(self):
    """
    Getter method for portnameonems, mapped from YANG variable /components/component/model/ports/port/portnameonems (string)

    YANG Description: Port Name (EMS/CLI)
    """
    return self.__portnameonems
      
  def _set_portnameonems(self, v, load=False):
    """
    Setter method for portnameonems, mapped from YANG variable /components/component/model/ports/port/portnameonems (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_portnameonems is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_portnameonems() directly.

    YANG Description: Port Name (EMS/CLI)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="portnameonems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """portnameonems must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="portnameonems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__portnameonems = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_portnameonems(self):
    self.__portnameonems = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="portnameonems", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_portnumber(self):
    """
    Getter method for portnumber, mapped from YANG variable /components/component/model/ports/port/portnumber (string)

    YANG Description: Port Number
    """
    return self.__portnumber
      
  def _set_portnumber(self, v, load=False):
    """
    Setter method for portnumber, mapped from YANG variable /components/component/model/ports/port/portnumber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_portnumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_portnumber() directly.

    YANG Description: Port Number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="portnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """portnumber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="portnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__portnumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_portnumber(self):
    self.__portnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="portnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_side(self):
    """
    Getter method for side, mapped from YANG variable /components/component/model/ports/port/side (string)

    YANG Description: Front/Rear
    """
    return self.__side
      
  def _set_side(self, v, load=False):
    """
    Setter method for side, mapped from YANG variable /components/component/model/ports/port/side (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_side is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_side() directly.

    YANG Description: Front/Rear
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """side must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__side = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_side(self):
    self.__side = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="side", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_connector(self):
    """
    Getter method for connector, mapped from YANG variable /components/component/model/ports/port/connector (string)

    YANG Description: Type of connector 
    """
    return self.__connector
      
  def _set_connector(self, v, load=False):
    """
    Setter method for connector, mapped from YANG variable /components/component/model/ports/port/connector (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connector is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connector() directly.

    YANG Description: Type of connector 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="connector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """connector must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__connector = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_connector(self):
    self.__connector = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="connector", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_tptype(self):
    """
    Getter method for tptype, mapped from YANG variable /components/component/model/ports/port/tptype (string)

    YANG Description: tp type
    """
    return self.__tptype
      
  def _set_tptype(self, v, load=False):
    """
    Setter method for tptype, mapped from YANG variable /components/component/model/ports/port/tptype (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tptype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tptype() directly.

    YANG Description: tp type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tptype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tptype must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tptype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__tptype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tptype(self):
    self.__tptype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tptype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_bandwidth(self):
    """
    Getter method for bandwidth, mapped from YANG variable /components/component/model/ports/port/bandwidth (string)

    YANG Description: Bandwidth
    """
    return self.__bandwidth
      
  def _set_bandwidth(self, v, load=False):
    """
    Setter method for bandwidth, mapped from YANG variable /components/component/model/ports/port/bandwidth (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Bandwidth
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bandwidth must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__bandwidth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bandwidth(self):
    self.__bandwidth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_digitalwrap(self):
    """
    Getter method for digitalwrap, mapped from YANG variable /components/component/model/ports/port/digitalwrap (string)

    YANG Description: Digital Wrap
    """
    return self.__digitalwrap
      
  def _set_digitalwrap(self, v, load=False):
    """
    Setter method for digitalwrap, mapped from YANG variable /components/component/model/ports/port/digitalwrap (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_digitalwrap is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_digitalwrap() directly.

    YANG Description: Digital Wrap
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="digitalwrap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """digitalwrap must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="digitalwrap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__digitalwrap = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_digitalwrap(self):
    self.__digitalwrap = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="digitalwrap", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_channelization(self):
    """
    Getter method for channelization, mapped from YANG variable /components/component/model/ports/port/channelization (string)

    YANG Description: Channelization
    """
    return self.__channelization
      
  def _set_channelization(self, v, load=False):
    """
    Setter method for channelization, mapped from YANG variable /components/component/model/ports/port/channelization (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_channelization is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_channelization() directly.

    YANG Description: Channelization
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="channelization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """channelization must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channelization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__channelization = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_channelization(self):
    self.__channelization = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="channelization", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /components/component/model/ports/port/status (string)

    YANG Description: Status
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /components/component/model/ports/port/status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Status
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_relationtype(self):
    """
    Getter method for relationtype, mapped from YANG variable /components/component/model/ports/port/relationtype (string)

    YANG Description: Relation Type
    """
    return self.__relationtype
      
  def _set_relationtype(self, v, load=False):
    """
    Setter method for relationtype, mapped from YANG variable /components/component/model/ports/port/relationtype (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relationtype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relationtype() directly.

    YANG Description: Relation Type
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="relationtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relationtype must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relationtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__relationtype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relationtype(self):
    self.__relationtype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relationtype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_relatedport(self):
    """
    Getter method for relatedport, mapped from YANG variable /components/component/model/ports/port/relatedport (string)

    YANG Description: Related Port
    """
    return self.__relatedport
      
  def _set_relatedport(self, v, load=False):
    """
    Setter method for relatedport, mapped from YANG variable /components/component/model/ports/port/relatedport (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relatedport is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relatedport() directly.

    YANG Description: Related Port
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="relatedport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """relatedport must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relatedport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__relatedport = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_relatedport(self):
    self.__relatedport = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="relatedport", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_parentportname(self):
    """
    Getter method for parentportname, mapped from YANG variable /components/component/model/ports/port/parentportname (string)

    YANG Description: Parent Port Name
    """
    return self.__parentportname
      
  def _set_parentportname(self, v, load=False):
    """
    Setter method for parentportname, mapped from YANG variable /components/component/model/ports/port/parentportname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parentportname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parentportname() directly.

    YANG Description: Parent Port Name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="parentportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parentportname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parentportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__parentportname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parentportname(self):
    self.__parentportname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parentportname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dualconnname(self):
    """
    Getter method for dualconnname, mapped from YANG variable /components/component/model/ports/port/dualconnname (string)

    YANG Description: Dual Conn Name
    """
    return self.__dualconnname
      
  def _set_dualconnname(self, v, load=False):
    """
    Setter method for dualconnname, mapped from YANG variable /components/component/model/ports/port/dualconnname (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dualconnname is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dualconnname() directly.

    YANG Description: Dual Conn Name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dualconnname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dualconnname must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dualconnname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dualconnname = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dualconnname(self):
    self.__dualconnname = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dualconnname", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dualconnindicator(self):
    """
    Getter method for dualconnindicator, mapped from YANG variable /components/component/model/ports/port/dualconnindicator (string)

    YANG Description: Dual Conn Indicator
    """
    return self.__dualconnindicator
      
  def _set_dualconnindicator(self, v, load=False):
    """
    Setter method for dualconnindicator, mapped from YANG variable /components/component/model/ports/port/dualconnindicator (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dualconnindicator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dualconnindicator() directly.

    YANG Description: Dual Conn Indicator
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dualconnindicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dualconnindicator must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dualconnindicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dualconnindicator = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dualconnindicator(self):
    self.__dualconnindicator = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dualconnindicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_direction(self):
    """
    Getter method for direction, mapped from YANG variable /components/component/model/ports/port/direction (string)

    YANG Description: Direction
    """
    return self.__direction
      
  def _set_direction(self, v, load=False):
    """
    Setter method for direction, mapped from YANG variable /components/component/model/ports/port/direction (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: Direction
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """direction must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__direction = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_direction(self):
    self.__direction = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/model/ports/port/description (string)

    YANG Description: Description
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/model/ports/port/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_aid(self):
    """
    Getter method for aid, mapped from YANG variable /components/component/model/ports/port/aid (string)

    YANG Description: AID
    """
    return self.__aid
      
  def _set_aid(self, v, load=False):
    """
    Setter method for aid, mapped from YANG variable /components/component/model/ports/port/aid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aid() directly.

    YANG Description: AID
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__aid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aid(self):
    self.__aid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_formula(self):
    """
    Getter method for formula, mapped from YANG variable /components/component/model/ports/port/formula (string)

    YANG Description: Formula
    """
    return self.__formula
      
  def _set_formula(self, v, load=False):
    """
    Setter method for formula, mapped from YANG variable /components/component/model/ports/port/formula (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_formula is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_formula() directly.

    YANG Description: Formula
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="formula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """formula must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="formula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__formula = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_formula(self):
    self.__formula = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="formula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /components/component/model/ports/port/weight (string)

    YANG Description: Weight
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /components/component/model/ports/port/weight (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: Weight
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_height(self):
    """
    Getter method for height, mapped from YANG variable /components/component/model/ports/port/height (string)

    YANG Description: Height
    """
    return self.__height
      
  def _set_height(self, v, load=False):
    """
    Setter method for height, mapped from YANG variable /components/component/model/ports/port/height (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_height is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_height() directly.

    YANG Description: Height
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """height must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__height = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_height(self):
    self.__height = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_width(self):
    """
    Getter method for width, mapped from YANG variable /components/component/model/ports/port/width (string)

    YANG Description: Width
    """
    return self.__width
      
  def _set_width(self, v, load=False):
    """
    Setter method for width, mapped from YANG variable /components/component/model/ports/port/width (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_width is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_width() directly.

    YANG Description: Width
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """width must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__width = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_width(self):
    self.__width = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_depth(self):
    """
    Getter method for depth, mapped from YANG variable /components/component/model/ports/port/depth (string)

    YANG Description: Depth
    """
    return self.__depth
      
  def _set_depth(self, v, load=False):
    """
    Setter method for depth, mapped from YANG variable /components/component/model/ports/port/depth (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_depth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_depth() directly.

    YANG Description: Depth
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """depth must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__depth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_depth(self):
    self.__depth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtobase(self):
    """
    Getter method for dimtobase, mapped from YANG variable /components/component/model/ports/port/dimtobase (string)

    YANG Description: Dim to Base
    """
    return self.__dimtobase
      
  def _set_dimtobase(self, v, load=False):
    """
    Setter method for dimtobase, mapped from YANG variable /components/component/model/ports/port/dimtobase (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtobase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtobase() directly.

    YANG Description: Dim to Base
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtobase must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtobase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtobase(self):
    self.__dimtobase = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtoleft(self):
    """
    Getter method for dimtoleft, mapped from YANG variable /components/component/model/ports/port/dimtoleft (string)

    YANG Description: Dim to Left
    """
    return self.__dimtoleft
      
  def _set_dimtoleft(self, v, load=False):
    """
    Setter method for dimtoleft, mapped from YANG variable /components/component/model/ports/port/dimtoleft (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtoleft is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtoleft() directly.

    YANG Description: Dim to Left
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtoleft must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtoleft = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtoleft(self):
    self.__dimtoleft = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtofront(self):
    """
    Getter method for dimtofront, mapped from YANG variable /components/component/model/ports/port/dimtofront (string)

    YANG Description: Dim to Front
    """
    return self.__dimtofront
      
  def _set_dimtofront(self, v, load=False):
    """
    Setter method for dimtofront, mapped from YANG variable /components/component/model/ports/port/dimtofront (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtofront is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtofront() directly.

    YANG Description: Dim to Front
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtofront must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtofront = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtofront(self):
    self.__dimtofront = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtotop(self):
    """
    Getter method for dimtotop, mapped from YANG variable /components/component/model/ports/port/dimtotop (string)

    YANG Description: Dim to Top
    """
    return self.__dimtotop
      
  def _set_dimtotop(self, v, load=False):
    """
    Setter method for dimtotop, mapped from YANG variable /components/component/model/ports/port/dimtotop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtotop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtotop() directly.

    YANG Description: Dim to Top
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtotop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtotop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtotop(self):
    self.__dimtotop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_subclass(self):
    """
    Getter method for subclass, mapped from YANG variable /components/component/model/ports/port/subclass (string)

    YANG Description: Subclass
    """
    return self.__subclass
      
  def _set_subclass(self, v, load=False):
    """
    Setter method for subclass, mapped from YANG variable /components/component/model/ports/port/subclass (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subclass is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subclass() directly.

    YANG Description: Subclass
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subclass must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__subclass = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subclass(self):
    self.__subclass = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_trafficBearing(self):
    """
    Getter method for trafficBearing, mapped from YANG variable /components/component/model/ports/port/trafficBearing (string)

    YANG Description: Traffic Bearing (Y/N)
    """
    return self.__trafficBearing
      
  def _set_trafficBearing(self, v, load=False):
    """
    Setter method for trafficBearing, mapped from YANG variable /components/component/model/ports/port/trafficBearing (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficBearing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficBearing() directly.

    YANG Description: Traffic Bearing (Y/N)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficBearing must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__trafficBearing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficBearing(self):
    self.__trafficBearing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)

  physicalportname = __builtin__.property(_get_physicalportname, _set_physicalportname)
  portnameonems = __builtin__.property(_get_portnameonems, _set_portnameonems)
  portnumber = __builtin__.property(_get_portnumber, _set_portnumber)
  side = __builtin__.property(_get_side, _set_side)
  connector = __builtin__.property(_get_connector, _set_connector)
  tptype = __builtin__.property(_get_tptype, _set_tptype)
  bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)
  digitalwrap = __builtin__.property(_get_digitalwrap, _set_digitalwrap)
  channelization = __builtin__.property(_get_channelization, _set_channelization)
  status = __builtin__.property(_get_status, _set_status)
  relationtype = __builtin__.property(_get_relationtype, _set_relationtype)
  relatedport = __builtin__.property(_get_relatedport, _set_relatedport)
  parentportname = __builtin__.property(_get_parentportname, _set_parentportname)
  dualconnname = __builtin__.property(_get_dualconnname, _set_dualconnname)
  dualconnindicator = __builtin__.property(_get_dualconnindicator, _set_dualconnindicator)
  direction = __builtin__.property(_get_direction, _set_direction)
  description = __builtin__.property(_get_description, _set_description)
  aid = __builtin__.property(_get_aid, _set_aid)
  formula = __builtin__.property(_get_formula, _set_formula)
  weight = __builtin__.property(_get_weight, _set_weight)
  height = __builtin__.property(_get_height, _set_height)
  width = __builtin__.property(_get_width, _set_width)
  depth = __builtin__.property(_get_depth, _set_depth)
  dimtobase = __builtin__.property(_get_dimtobase, _set_dimtobase)
  dimtoleft = __builtin__.property(_get_dimtoleft, _set_dimtoleft)
  dimtofront = __builtin__.property(_get_dimtofront, _set_dimtofront)
  dimtotop = __builtin__.property(_get_dimtotop, _set_dimtotop)
  subclass = __builtin__.property(_get_subclass, _set_subclass)
  trafficBearing = __builtin__.property(_get_trafficBearing, _set_trafficBearing)


  _pyangbind_elements = OrderedDict([('physicalportname', physicalportname), ('portnameonems', portnameonems), ('portnumber', portnumber), ('side', side), ('connector', connector), ('tptype', tptype), ('bandwidth', bandwidth), ('digitalwrap', digitalwrap), ('channelization', channelization), ('status', status), ('relationtype', relationtype), ('relatedport', relatedport), ('parentportname', parentportname), ('dualconnname', dualconnname), ('dualconnindicator', dualconnindicator), ('direction', direction), ('description', description), ('aid', aid), ('formula', formula), ('weight', weight), ('height', height), ('width', width), ('depth', depth), ('dimtobase', dimtobase), ('dimtoleft', dimtoleft), ('dimtofront', dimtofront), ('dimtotop', dimtotop), ('subclass', subclass), ('trafficBearing', trafficBearing), ])


class yc_ports_openconfig_platform__components_component_model_ports(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/model/ports. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: ports on the component
  """
  __slots__ = ('_path_helper', '_extmethods', '__port',)

  _yang_name = 'ports'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__port = YANGDynClass(base=YANGListType("physicalportname",yc_port_openconfig_platform__components_component_model_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='physicalportname', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'model', 'ports']

  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /components/component/model/ports/port (list)

    YANG Description: List of ports
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /components/component/model/ports/port (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: List of ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("physicalportname",yc_port_openconfig_platform__components_component_model_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='physicalportname', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("physicalportname",yc_port_openconfig_platform__components_component_model_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='physicalportname', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=YANGListType("physicalportname",yc_port_openconfig_platform__components_component_model_ports_port, yang_name="port", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='physicalportname', extensions=None), is_container='list', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='list', is_config=True)

  port = __builtin__.property(_get_port, _set_port)


  _pyangbind_elements = OrderedDict([('port', port), ])


class yc_model_openconfig_platform__components_component_model(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component/model. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__templatename','__facing','__containedtemplate','__partnumber','__materialid','__sapcode','__clei_7','__manufacturer','__componenttype','__status','__aidformula','__aidrule','__description','__numberofports','__weight','__height','__width','__depth','__dimtobase','__dimtoleft','__dimtofront','__dimtotop','__subclass','__trafficBearing','__slots','__ports',)

  _yang_name = 'model'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__templatename = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="templatename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__facing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__containedtemplate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="containedtemplate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__partnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="partnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__materialid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="materialid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__sapcode = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sapcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__clei_7 = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="clei_7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__manufacturer = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="manufacturer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__componenttype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="componenttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__aidformula = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aidformula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__aidrule = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aidrule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__numberofports = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="numberofports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__weight = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__height = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__width = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__depth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtobase = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtoleft = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtofront = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__dimtotop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__subclass = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__trafficBearing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    self.__slots = YANGDynClass(base=yc_slots_openconfig_platform__components_component_model_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)
    self.__ports = YANGDynClass(base=yc_ports_openconfig_platform__components_component_model_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component', 'model']

  def _get_templatename(self):
    """
    Getter method for templatename, mapped from YANG variable /components/component/model/templatename (string)

    YANG Description: Template Name
    """
    return self.__templatename
      
  def _set_templatename(self, v, load=False):
    """
    Setter method for templatename, mapped from YANG variable /components/component/model/templatename (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_templatename is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_templatename() directly.

    YANG Description: Template Name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="templatename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """templatename must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="templatename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__templatename = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_templatename(self):
    self.__templatename = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="templatename", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_facing(self):
    """
    Getter method for facing, mapped from YANG variable /components/component/model/facing (string)

    YANG Description: front or rear facing
    """
    return self.__facing
      
  def _set_facing(self, v, load=False):
    """
    Setter method for facing, mapped from YANG variable /components/component/model/facing (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_facing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_facing() directly.

    YANG Description: front or rear facing
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="facing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """facing must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__facing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_facing(self):
    self.__facing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="facing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_containedtemplate(self):
    """
    Getter method for containedtemplate, mapped from YANG variable /components/component/model/containedtemplate (string)

    YANG Description: Template Name of the container e.g Rack in case of shelf
    """
    return self.__containedtemplate
      
  def _set_containedtemplate(self, v, load=False):
    """
    Setter method for containedtemplate, mapped from YANG variable /components/component/model/containedtemplate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_containedtemplate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_containedtemplate() directly.

    YANG Description: Template Name of the container e.g Rack in case of shelf
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="containedtemplate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """containedtemplate must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="containedtemplate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__containedtemplate = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_containedtemplate(self):
    self.__containedtemplate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="containedtemplate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_partnumber(self):
    """
    Getter method for partnumber, mapped from YANG variable /components/component/model/partnumber (string)

    YANG Description: Part Number
    """
    return self.__partnumber
      
  def _set_partnumber(self, v, load=False):
    """
    Setter method for partnumber, mapped from YANG variable /components/component/model/partnumber (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partnumber is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partnumber() directly.

    YANG Description: Part Number
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="partnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partnumber must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="partnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__partnumber = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partnumber(self):
    self.__partnumber = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="partnumber", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_materialid(self):
    """
    Getter method for materialid, mapped from YANG variable /components/component/model/materialid (string)

    YANG Description: Material Id
    """
    return self.__materialid
      
  def _set_materialid(self, v, load=False):
    """
    Setter method for materialid, mapped from YANG variable /components/component/model/materialid (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_materialid is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_materialid() directly.

    YANG Description: Material Id
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="materialid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """materialid must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="materialid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__materialid = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_materialid(self):
    self.__materialid = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="materialid", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_sapcode(self):
    """
    Getter method for sapcode, mapped from YANG variable /components/component/model/sapcode (string)

    YANG Description: SAP Code
    """
    return self.__sapcode
      
  def _set_sapcode(self, v, load=False):
    """
    Setter method for sapcode, mapped from YANG variable /components/component/model/sapcode (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sapcode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sapcode() directly.

    YANG Description: SAP Code
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="sapcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """sapcode must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sapcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__sapcode = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_sapcode(self):
    self.__sapcode = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sapcode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_clei_7(self):
    """
    Getter method for clei_7, mapped from YANG variable /components/component/model/clei_7 (string)

    YANG Description: CLEI Code
    """
    return self.__clei_7
      
  def _set_clei_7(self, v, load=False):
    """
    Setter method for clei_7, mapped from YANG variable /components/component/model/clei_7 (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clei_7 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clei_7() directly.

    YANG Description: CLEI Code
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="clei_7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """clei_7 must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="clei_7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__clei_7 = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_clei_7(self):
    self.__clei_7 = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="clei_7", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_manufacturer(self):
    """
    Getter method for manufacturer, mapped from YANG variable /components/component/model/manufacturer (string)

    YANG Description: Manufacturer
    """
    return self.__manufacturer
      
  def _set_manufacturer(self, v, load=False):
    """
    Setter method for manufacturer, mapped from YANG variable /components/component/model/manufacturer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manufacturer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manufacturer() directly.

    YANG Description: Manufacturer
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="manufacturer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manufacturer must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="manufacturer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__manufacturer = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manufacturer(self):
    self.__manufacturer = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="manufacturer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_componenttype(self):
    """
    Getter method for componenttype, mapped from YANG variable /components/component/model/componenttype (string)

    YANG Description: Category/Equip Type Model Name
    """
    return self.__componenttype
      
  def _set_componenttype(self, v, load=False):
    """
    Setter method for componenttype, mapped from YANG variable /components/component/model/componenttype (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_componenttype is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_componenttype() directly.

    YANG Description: Category/Equip Type Model Name
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="componenttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """componenttype must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="componenttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__componenttype = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_componenttype(self):
    self.__componenttype = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="componenttype", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_status(self):
    """
    Getter method for status, mapped from YANG variable /components/component/model/status (string)

    YANG Description: Status of the component
    """
    return self.__status
      
  def _set_status(self, v, load=False):
    """
    Setter method for status, mapped from YANG variable /components/component/model/status (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_status is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_status() directly.

    YANG Description: Status of the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """status must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__status = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_status(self):
    self.__status = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="status", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_aidformula(self):
    """
    Getter method for aidformula, mapped from YANG variable /components/component/model/aidformula (string)

    YANG Description: AID Formula
    """
    return self.__aidformula
      
  def _set_aidformula(self, v, load=False):
    """
    Setter method for aidformula, mapped from YANG variable /components/component/model/aidformula (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aidformula is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aidformula() directly.

    YANG Description: AID Formula
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aidformula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aidformula must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aidformula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__aidformula = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aidformula(self):
    self.__aidformula = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aidformula", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_aidrule(self):
    """
    Getter method for aidrule, mapped from YANG variable /components/component/model/aidrule (string)

    YANG Description: AID Rule
    """
    return self.__aidrule
      
  def _set_aidrule(self, v, load=False):
    """
    Setter method for aidrule, mapped from YANG variable /components/component/model/aidrule (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aidrule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aidrule() directly.

    YANG Description: AID Rule
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="aidrule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """aidrule must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aidrule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__aidrule = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_aidrule(self):
    self.__aidrule = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="aidrule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_description(self):
    """
    Getter method for description, mapped from YANG variable /components/component/model/description (string)

    YANG Description: Description
    """
    return self.__description
      
  def _set_description(self, v, load=False):
    """
    Setter method for description, mapped from YANG variable /components/component/model/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """description must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__description = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_description(self):
    self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_numberofports(self):
    """
    Getter method for numberofports, mapped from YANG variable /components/component/model/numberofports (string)

    YANG Description: Number of Ports
    """
    return self.__numberofports
      
  def _set_numberofports(self, v, load=False):
    """
    Setter method for numberofports, mapped from YANG variable /components/component/model/numberofports (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numberofports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numberofports() directly.

    YANG Description: Number of Ports
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="numberofports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numberofports must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="numberofports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__numberofports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numberofports(self):
    self.__numberofports = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="numberofports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_weight(self):
    """
    Getter method for weight, mapped from YANG variable /components/component/model/weight (string)

    YANG Description: Weight
    """
    return self.__weight
      
  def _set_weight(self, v, load=False):
    """
    Setter method for weight, mapped from YANG variable /components/component/model/weight (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_weight is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_weight() directly.

    YANG Description: Weight
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """weight must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__weight = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_weight(self):
    self.__weight = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="weight", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_height(self):
    """
    Getter method for height, mapped from YANG variable /components/component/model/height (string)

    YANG Description: Height
    """
    return self.__height
      
  def _set_height(self, v, load=False):
    """
    Setter method for height, mapped from YANG variable /components/component/model/height (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_height is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_height() directly.

    YANG Description: Height
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """height must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__height = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_height(self):
    self.__height = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="height", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_width(self):
    """
    Getter method for width, mapped from YANG variable /components/component/model/width (string)

    YANG Description: Width
    """
    return self.__width
      
  def _set_width(self, v, load=False):
    """
    Setter method for width, mapped from YANG variable /components/component/model/width (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_width is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_width() directly.

    YANG Description: Width
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """width must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__width = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_width(self):
    self.__width = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="width", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_depth(self):
    """
    Getter method for depth, mapped from YANG variable /components/component/model/depth (string)

    YANG Description: Depth
    """
    return self.__depth
      
  def _set_depth(self, v, load=False):
    """
    Setter method for depth, mapped from YANG variable /components/component/model/depth (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_depth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_depth() directly.

    YANG Description: Depth
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """depth must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__depth = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_depth(self):
    self.__depth = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="depth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtobase(self):
    """
    Getter method for dimtobase, mapped from YANG variable /components/component/model/dimtobase (string)

    YANG Description: Dim to Base
    """
    return self.__dimtobase
      
  def _set_dimtobase(self, v, load=False):
    """
    Setter method for dimtobase, mapped from YANG variable /components/component/model/dimtobase (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtobase is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtobase() directly.

    YANG Description: Dim to Base
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtobase must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtobase = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtobase(self):
    self.__dimtobase = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtobase", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtoleft(self):
    """
    Getter method for dimtoleft, mapped from YANG variable /components/component/model/dimtoleft (string)

    YANG Description: Dim to Left
    """
    return self.__dimtoleft
      
  def _set_dimtoleft(self, v, load=False):
    """
    Setter method for dimtoleft, mapped from YANG variable /components/component/model/dimtoleft (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtoleft is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtoleft() directly.

    YANG Description: Dim to Left
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtoleft must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtoleft = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtoleft(self):
    self.__dimtoleft = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtoleft", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtofront(self):
    """
    Getter method for dimtofront, mapped from YANG variable /components/component/model/dimtofront (string)

    YANG Description: Dim to Front
    """
    return self.__dimtofront
      
  def _set_dimtofront(self, v, load=False):
    """
    Setter method for dimtofront, mapped from YANG variable /components/component/model/dimtofront (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtofront is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtofront() directly.

    YANG Description: Dim to Front
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtofront must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtofront = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtofront(self):
    self.__dimtofront = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtofront", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_dimtotop(self):
    """
    Getter method for dimtotop, mapped from YANG variable /components/component/model/dimtotop (string)

    YANG Description: Dim to Top
    """
    return self.__dimtotop
      
  def _set_dimtotop(self, v, load=False):
    """
    Setter method for dimtotop, mapped from YANG variable /components/component/model/dimtotop (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dimtotop is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dimtotop() directly.

    YANG Description: Dim to Top
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dimtotop must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__dimtotop = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dimtotop(self):
    self.__dimtotop = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dimtotop", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_subclass(self):
    """
    Getter method for subclass, mapped from YANG variable /components/component/model/subclass (string)

    YANG Description: Subclass
    """
    return self.__subclass
      
  def _set_subclass(self, v, load=False):
    """
    Setter method for subclass, mapped from YANG variable /components/component/model/subclass (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subclass is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subclass() directly.

    YANG Description: Subclass
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subclass must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__subclass = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subclass(self):
    self.__subclass = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="subclass", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_trafficBearing(self):
    """
    Getter method for trafficBearing, mapped from YANG variable /components/component/model/trafficBearing (string)

    YANG Description: Traffic Bearing (Y/N)
    """
    return self.__trafficBearing
      
  def _set_trafficBearing(self, v, load=False):
    """
    Setter method for trafficBearing, mapped from YANG variable /components/component/model/trafficBearing (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trafficBearing is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trafficBearing() directly.

    YANG Description: Traffic Bearing (Y/N)
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """trafficBearing must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)""",
        })

    self.__trafficBearing = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_trafficBearing(self):
    self.__trafficBearing = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="trafficBearing", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='string', is_config=True)


  def _get_slots(self):
    """
    Getter method for slots, mapped from YANG variable /components/component/model/slots (container)

    YANG Description: Slots on the component
    """
    return self.__slots
      
  def _set_slots(self, v, load=False):
    """
    Setter method for slots, mapped from YANG variable /components/component/model/slots (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_slots is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_slots() directly.

    YANG Description: Slots on the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_slots_openconfig_platform__components_component_model_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """slots must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_slots_openconfig_platform__components_component_model_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)""",
        })

    self.__slots = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_slots(self):
    self.__slots = YANGDynClass(base=yc_slots_openconfig_platform__components_component_model_slots, is_container='container', yang_name="slots", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)


  def _get_ports(self):
    """
    Getter method for ports, mapped from YANG variable /components/component/model/ports (container)

    YANG Description: ports on the component
    """
    return self.__ports
      
  def _set_ports(self, v, load=False):
    """
    Setter method for ports, mapped from YANG variable /components/component/model/ports (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ports is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ports() directly.

    YANG Description: ports on the component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_ports_openconfig_platform__components_component_model_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ports must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_ports_openconfig_platform__components_component_model_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)""",
        })

    self.__ports = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ports(self):
    self.__ports = YANGDynClass(base=yc_ports_openconfig_platform__components_component_model_ports, is_container='container', yang_name="ports", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)

  templatename = __builtin__.property(_get_templatename, _set_templatename)
  facing = __builtin__.property(_get_facing, _set_facing)
  containedtemplate = __builtin__.property(_get_containedtemplate, _set_containedtemplate)
  partnumber = __builtin__.property(_get_partnumber, _set_partnumber)
  materialid = __builtin__.property(_get_materialid, _set_materialid)
  sapcode = __builtin__.property(_get_sapcode, _set_sapcode)
  clei_7 = __builtin__.property(_get_clei_7, _set_clei_7)
  manufacturer = __builtin__.property(_get_manufacturer, _set_manufacturer)
  componenttype = __builtin__.property(_get_componenttype, _set_componenttype)
  status = __builtin__.property(_get_status, _set_status)
  aidformula = __builtin__.property(_get_aidformula, _set_aidformula)
  aidrule = __builtin__.property(_get_aidrule, _set_aidrule)
  description = __builtin__.property(_get_description, _set_description)
  numberofports = __builtin__.property(_get_numberofports, _set_numberofports)
  weight = __builtin__.property(_get_weight, _set_weight)
  height = __builtin__.property(_get_height, _set_height)
  width = __builtin__.property(_get_width, _set_width)
  depth = __builtin__.property(_get_depth, _set_depth)
  dimtobase = __builtin__.property(_get_dimtobase, _set_dimtobase)
  dimtoleft = __builtin__.property(_get_dimtoleft, _set_dimtoleft)
  dimtofront = __builtin__.property(_get_dimtofront, _set_dimtofront)
  dimtotop = __builtin__.property(_get_dimtotop, _set_dimtotop)
  subclass = __builtin__.property(_get_subclass, _set_subclass)
  trafficBearing = __builtin__.property(_get_trafficBearing, _set_trafficBearing)
  slots = __builtin__.property(_get_slots, _set_slots)
  ports = __builtin__.property(_get_ports, _set_ports)


  _pyangbind_elements = OrderedDict([('templatename', templatename), ('facing', facing), ('containedtemplate', containedtemplate), ('partnumber', partnumber), ('materialid', materialid), ('sapcode', sapcode), ('clei_7', clei_7), ('manufacturer', manufacturer), ('componenttype', componenttype), ('status', status), ('aidformula', aidformula), ('aidrule', aidrule), ('description', description), ('numberofports', numberofports), ('weight', weight), ('height', height), ('width', width), ('depth', depth), ('dimtobase', dimtobase), ('dimtoleft', dimtoleft), ('dimtofront', dimtofront), ('dimtotop', dimtotop), ('subclass', subclass), ('trafficBearing', trafficBearing), ('slots', slots), ('ports', ports), ])


class yc_component_openconfig_platform__components_component(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components/component. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of components, keyed by component name.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__config','__state','__properties','__subcomponents','__chassis','__port','__power_supply','__fan','__fabric','__storage','__cpu','__integrated_circuit','__backplane','__holder','__model',)

  _yang_name = 'component'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__properties = YANGDynClass(base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__subcomponents = YANGDynClass(base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__chassis = YANGDynClass(base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__port = YANGDynClass(base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__power_supply = YANGDynClass(base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__fan = YANGDynClass(base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__fabric = YANGDynClass(base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__storage = YANGDynClass(base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__cpu = YANGDynClass(base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__integrated_circuit = YANGDynClass(base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__backplane = YANGDynClass(base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    self.__holder = YANGDynClass(base=yc_holder_openconfig_platform__components_component_holder, is_container='container', yang_name="holder", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)
    self.__model = YANGDynClass(base=yc_model_openconfig_platform__components_component_model, is_container='container', yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components', 'component']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /components/component/name (leafref)

    YANG Description: References the component name
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /components/component/name (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: References the component name
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='leafref', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /components/component/config (container)

    YANG Description: Configuration data for each component
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /components/component/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: Configuration data for each component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_openconfig_platform__components_component_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /components/component/state (container)

    YANG Description: Operational state data for each component
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /components/component/state (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.

    YANG Description: Operational state data for each component
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=yc_state_openconfig_platform__components_component_state, is_container='container', yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_properties(self):
    """
    Getter method for properties, mapped from YANG variable /components/component/properties (container)

    YANG Description: Enclosing container 
    """
    return self.__properties
      
  def _set_properties(self, v, load=False):
    """
    Setter method for properties, mapped from YANG variable /components/component/properties (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_properties() directly.

    YANG Description: Enclosing container 
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """properties must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__properties = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_properties(self):
    self.__properties = YANGDynClass(base=yc_properties_openconfig_platform__components_component_properties, is_container='container', yang_name="properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_subcomponents(self):
    """
    Getter method for subcomponents, mapped from YANG variable /components/component/subcomponents (container)

    YANG Description: Enclosing container for subcomponent references
    """
    return self.__subcomponents
      
  def _set_subcomponents(self, v, load=False):
    """
    Setter method for subcomponents, mapped from YANG variable /components/component/subcomponents (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_subcomponents is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_subcomponents() directly.

    YANG Description: Enclosing container for subcomponent references
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """subcomponents must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__subcomponents = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_subcomponents(self):
    self.__subcomponents = YANGDynClass(base=yc_subcomponents_openconfig_platform__components_component_subcomponents, is_container='container', yang_name="subcomponents", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_chassis(self):
    """
    Getter method for chassis, mapped from YANG variable /components/component/chassis (container)

    YANG Description: Data for chassis components
    """
    return self.__chassis
      
  def _set_chassis(self, v, load=False):
    """
    Setter method for chassis, mapped from YANG variable /components/component/chassis (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_chassis is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_chassis() directly.

    YANG Description: Data for chassis components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """chassis must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__chassis = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_chassis(self):
    self.__chassis = YANGDynClass(base=yc_chassis_openconfig_platform__components_component_chassis, is_container='container', yang_name="chassis", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_port(self):
    """
    Getter method for port, mapped from YANG variable /components/component/port (container)

    YANG Description: Data for physical port components
    """
    return self.__port
      
  def _set_port(self, v, load=False):
    """
    Setter method for port, mapped from YANG variable /components/component/port (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port() directly.

    YANG Description: Data for physical port components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """port must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_port(self):
    self.__port = YANGDynClass(base=yc_port_openconfig_platform__components_component_port, is_container='container', yang_name="port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_power_supply(self):
    """
    Getter method for power_supply, mapped from YANG variable /components/component/power_supply (container)

    YANG Description: Data for power supply components
    """
    return self.__power_supply
      
  def _set_power_supply(self, v, load=False):
    """
    Setter method for power_supply, mapped from YANG variable /components/component/power_supply (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_power_supply is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_power_supply() directly.

    YANG Description: Data for power supply components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """power_supply must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__power_supply = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_power_supply(self):
    self.__power_supply = YANGDynClass(base=yc_power_supply_openconfig_platform__components_component_power_supply, is_container='container', yang_name="power-supply", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_fan(self):
    """
    Getter method for fan, mapped from YANG variable /components/component/fan (container)

    YANG Description: Data for fan components
    """
    return self.__fan
      
  def _set_fan(self, v, load=False):
    """
    Setter method for fan, mapped from YANG variable /components/component/fan (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fan is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fan() directly.

    YANG Description: Data for fan components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fan must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__fan = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fan(self):
    self.__fan = YANGDynClass(base=yc_fan_openconfig_platform__components_component_fan, is_container='container', yang_name="fan", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_fabric(self):
    """
    Getter method for fabric, mapped from YANG variable /components/component/fabric (container)

    YANG Description: Data for fabric components
    """
    return self.__fabric
      
  def _set_fabric(self, v, load=False):
    """
    Setter method for fabric, mapped from YANG variable /components/component/fabric (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fabric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fabric() directly.

    YANG Description: Data for fabric components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fabric must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__fabric = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fabric(self):
    self.__fabric = YANGDynClass(base=yc_fabric_openconfig_platform__components_component_fabric, is_container='container', yang_name="fabric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_storage(self):
    """
    Getter method for storage, mapped from YANG variable /components/component/storage (container)

    YANG Description: Data for storage components
    """
    return self.__storage
      
  def _set_storage(self, v, load=False):
    """
    Setter method for storage, mapped from YANG variable /components/component/storage (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_storage() directly.

    YANG Description: Data for storage components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """storage must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__storage = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_storage(self):
    self.__storage = YANGDynClass(base=yc_storage_openconfig_platform__components_component_storage, is_container='container', yang_name="storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_cpu(self):
    """
    Getter method for cpu, mapped from YANG variable /components/component/cpu (container)

    YANG Description: Data for cpu components
    """
    return self.__cpu
      
  def _set_cpu(self, v, load=False):
    """
    Setter method for cpu, mapped from YANG variable /components/component/cpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu() directly.

    YANG Description: Data for cpu components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cpu must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__cpu = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cpu(self):
    self.__cpu = YANGDynClass(base=yc_cpu_openconfig_platform__components_component_cpu, is_container='container', yang_name="cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_integrated_circuit(self):
    """
    Getter method for integrated_circuit, mapped from YANG variable /components/component/integrated_circuit (container)

    YANG Description: Data for chip components, such as ASIC, NPUs, etc.
    """
    return self.__integrated_circuit
      
  def _set_integrated_circuit(self, v, load=False):
    """
    Setter method for integrated_circuit, mapped from YANG variable /components/component/integrated_circuit (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_integrated_circuit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_integrated_circuit() directly.

    YANG Description: Data for chip components, such as ASIC, NPUs, etc.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """integrated_circuit must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__integrated_circuit = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_integrated_circuit(self):
    self.__integrated_circuit = YANGDynClass(base=yc_integrated_circuit_openconfig_platform__components_component_integrated_circuit, is_container='container', yang_name="integrated-circuit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_backplane(self):
    """
    Getter method for backplane, mapped from YANG variable /components/component/backplane (container)

    YANG Description: Data for backplane components
    """
    return self.__backplane
      
  def _set_backplane(self, v, load=False):
    """
    Setter method for backplane, mapped from YANG variable /components/component/backplane (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_backplane is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_backplane() directly.

    YANG Description: Data for backplane components
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """backplane must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__backplane = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_backplane(self):
    self.__backplane = YANGDynClass(base=yc_backplane_openconfig_platform__components_component_backplane, is_container='container', yang_name="backplane", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)


  def _get_holder(self):
    """
    Getter method for holder, mapped from YANG variable /components/component/holder (container)
    """
    return self.__holder
      
  def _set_holder(self, v, load=False):
    """
    Setter method for holder, mapped from YANG variable /components/component/holder (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_holder is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_holder() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_holder_openconfig_platform__components_component_holder, is_container='container', yang_name="holder", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """holder must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_holder_openconfig_platform__components_component_holder, is_container='container', yang_name="holder", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)""",
        })

    self.__holder = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_holder(self):
    self.__holder = YANGDynClass(base=yc_holder_openconfig_platform__components_component_holder, is_container='container', yang_name="holder", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform-equipment-holder', defining_module='vz-udm-platform-equipment-holder', yang_type='container', is_config=True)


  def _get_model(self):
    """
    Getter method for model, mapped from YANG variable /components/component/model (container)
    """
    return self.__model
      
  def _set_model(self, v, load=False):
    """
    Setter method for model, mapped from YANG variable /components/component/model (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_model is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_model() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_model_openconfig_platform__components_component_model, is_container='container', yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """model must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_model_openconfig_platform__components_component_model, is_container='container', yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)""",
        })

    self.__model = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_model(self):
    self.__model = YANGDynClass(base=yc_model_openconfig_platform__components_component_model, is_container='container', yang_name="model", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:onf:params:xml:ns:yang:vz-udm-platform', defining_module='vz-udm-platform-equipment-model', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  config = __builtin__.property(_get_config, _set_config)
  state = __builtin__.property(_get_state, _set_state)
  properties = __builtin__.property(_get_properties, _set_properties)
  subcomponents = __builtin__.property(_get_subcomponents, _set_subcomponents)
  chassis = __builtin__.property(_get_chassis, _set_chassis)
  port = __builtin__.property(_get_port, _set_port)
  power_supply = __builtin__.property(_get_power_supply, _set_power_supply)
  fan = __builtin__.property(_get_fan, _set_fan)
  fabric = __builtin__.property(_get_fabric, _set_fabric)
  storage = __builtin__.property(_get_storage, _set_storage)
  cpu = __builtin__.property(_get_cpu, _set_cpu)
  integrated_circuit = __builtin__.property(_get_integrated_circuit, _set_integrated_circuit)
  backplane = __builtin__.property(_get_backplane, _set_backplane)
  holder = __builtin__.property(_get_holder, _set_holder)
  model = __builtin__.property(_get_model, _set_model)


  _pyangbind_elements = OrderedDict([('name', name), ('config', config), ('state', state), ('properties', properties), ('subcomponents', subcomponents), ('chassis', chassis), ('port', port), ('power_supply', power_supply), ('fan', fan), ('fabric', fabric), ('storage', storage), ('cpu', cpu), ('integrated_circuit', integrated_circuit), ('backplane', backplane), ('holder', holder), ('model', model), ])


class yc_components_openconfig_platform__components(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /components. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Enclosing container for the components in the system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__component',)

  _yang_name = 'components'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__component = YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['components']

  def _get_component(self):
    """
    Getter method for component, mapped from YANG variable /components/component (list)

    YANG Description: List of components, keyed by component name.
    """
    return self.__component
      
  def _set_component(self, v, load=False):
    """
    Setter method for component, mapped from YANG variable /components/component (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_component is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_component() directly.

    YANG Description: List of components, keyed by component name.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """component must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)""",
        })

    self.__component = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_component(self):
    self.__component = YANGDynClass(base=YANGListType("name",yc_component_openconfig_platform__components_component, yang_name="component", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="component", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='list', is_config=True)

  component = __builtin__.property(_get_component, _set_component)


  _pyangbind_elements = OrderedDict([('component', component), ])


class openconfig_platform(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module openconfig-platform - based on the path /openconfig-platform. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a data model for representing a system
component inventory, which can include hardware or software
elements arranged in an arbitrary structure. The primary
relationship supported by the model is containment, e.g.,
components containing subcomponents.

It is expected that this model reflects every field replacable
unit on the device at a minimum (i.e., additional information
may be supplied about non-replacable components).

Every element in the inventory is termed a 'component' with each
component expected to have a unique name and type, and optionally
a unique system-assigned identifier and FRU number.  The
uniqueness is guaranteed by the system within the device.

Components may have properties defined by the system that are
modeled as a list of key-value pairs. These may or may not be
user-configurable.  The model provides a flag for the system
to optionally indicate which properties are user configurable.

Each component also has a list of 'subcomponents' which are
references to other components. Appearance in a list of
subcomponents indicates a containment relationship as described
above.  For example, a linecard component may have a list of
references to port components that reside on the linecard.

This schema is generic to allow devices to express their own
platform-specific structure.  It may be augmented by additional
component type-specific schemas that provide a common structure
for well-known component types.  In these cases, the system is
expected to populate the common component schema, and may
optionally also represent the component and its properties in the
generic structure.

The properties for each component may include dynamic values,
e.g., in the 'state' part of the schema.  For example, a CPU
component may report its utilization, temperature, or other
physical properties.  The intent is to capture all platform-
specific physical data in one location, including inventory
(presence or absence of a component) and state (physical
attributes or status).
  """
  __slots__ = ('_path_helper', '_extmethods', '__components',)

  _yang_name = 'openconfig-platform'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__components = YANGDynClass(base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_components(self):
    """
    Getter method for components, mapped from YANG variable /components (container)

    YANG Description: Enclosing container for the components in the system.
    """
    return self.__components
      
  def _set_components(self, v, load=False):
    """
    Setter method for components, mapped from YANG variable /components (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_components is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_components() directly.

    YANG Description: Enclosing container for the components in the system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """components must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)""",
        })

    self.__components = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_components(self):
    self.__components = YANGDynClass(base=yc_components_openconfig_platform__components, is_container='container', yang_name="components", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://openconfig.net/yang/platform', defining_module='openconfig-platform', yang_type='container', is_config=True)

  components = __builtin__.property(_get_components, _set_components)


  _pyangbind_elements = OrderedDict([('components', components), ])


