# Copyright Verizon Inc. 
# Licensed under the terms of the Apache License 2.0 license.  
# See LICENSE file in project root for terms.
# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class ietf_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-inet-types - based on the path /ietf-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types for Internet addresses and related things.

Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

class yc_supporting_network_ietf_network__networks_network_supporting_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/supporting-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: An underlay network, used to represent layered network
topologies.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref',)

  _yang_name = 'supporting-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'supporting-network']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/supporting_network/network_ref (leafref)

    YANG Description: References the underlay network.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/supporting_network/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: References the underlay network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

  network_ref = __builtin__.property(_get_network_ref, _set_network_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ])


class yc_supporting_node_ietf_network__networks_network_node_supporting_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/node/supporting-node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref','__node_ref',)

  _yang_name = 'supporting-node'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'node', 'supporting-node']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/node/supporting_node/network_ref (leafref)

    YANG Description: References the underlay network of which the
underlay node is a part.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/node/supporting_node/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: References the underlay network of which the
underlay node is a part.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)


  def _get_node_ref(self):
    """
    Getter method for node_ref, mapped from YANG variable /networks/network/node/supporting_node/node_ref (leafref)

    YANG Description: References the underlay node itself.
    """
    return self.__node_ref
      
  def _set_node_ref(self, v, load=False):
    """
    Setter method for node_ref, mapped from YANG variable /networks/network/node/supporting_node/node_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_ref() directly.

    YANG Description: References the underlay node itself.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)""",
        })

    self.__node_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_ref(self):
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='leafref', is_config=True)

  network_ref = __builtin__.property(_get_network_ref, _set_network_ref)
  node_ref = __builtin__.property(_get_node_ref, _set_node_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ('node_ref', node_ref), ])


class yc_supporting_termination_point_ietf_network__networks_network_node_termination_point_supporting_termination_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/node/termination-point/supporting-termination-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list identifies any termination points on which a
given termination point depends or onto which it maps.
Those termination points will themselves be contained
in a supporting node.  This dependency information can be
inferred from the dependencies between links.  Therefore,
this item is not separately configurable.  Hence, no
corresponding constraint needs to be articulated.
The corresponding information is simply provided by the
implementing system.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref','__node_ref','__tp_ref',)

  _yang_name = 'supporting-termination-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    self.__tp_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tp-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'node', 'termination-point', 'supporting-termination-point']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point/network_ref (leafref)

    YANG Description: This leaf identifies in which topology the
supporting termination point is present.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: This leaf identifies in which topology the
supporting termination point is present.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)


  def _get_node_ref(self):
    """
    Getter method for node_ref, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point/node_ref (leafref)

    YANG Description: This leaf identifies in which node the supporting
termination point is present.
    """
    return self.__node_ref
      
  def _set_node_ref(self, v, load=False):
    """
    Setter method for node_ref, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point/node_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_ref() directly.

    YANG Description: This leaf identifies in which node the supporting
termination point is present.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__node_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_ref(self):
    self.__node_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)


  def _get_tp_ref(self):
    """
    Getter method for tp_ref, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point/tp_ref (leafref)

    YANG Description: Reference to the underlay node (the underlay node must
be in a different topology).
    """
    return self.__tp_ref
      
  def _set_tp_ref(self, v, load=False):
    """
    Setter method for tp_ref, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point/tp_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tp_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tp_ref() directly.

    YANG Description: Reference to the underlay node (the underlay node must
be in a different topology).
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tp-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tp_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tp-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__tp_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tp_ref(self):
    self.__tp_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tp-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

  network_ref = __builtin__.property(_get_network_ref, _set_network_ref)
  node_ref = __builtin__.property(_get_node_ref, _set_node_ref)
  tp_ref = __builtin__.property(_get_tp_ref, _set_tp_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ('node_ref', node_ref), ('tp_ref', tp_ref), ])


class yc_termination_point_ietf_network__networks_network_node_termination_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/node/termination-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A termination point can terminate a link.
Depending on the type of topology, a termination point
could, for example, refer to a port or an interface.
  """
  __slots__ = ('_path_helper', '_extmethods', '__tp_id','__supporting_termination_point',)

  _yang_name = 'termination-point'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__tp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='tp-id', is_config=True)
    self.__supporting_termination_point = YANGDynClass(base=YANGListType("network_ref node_ref tp_ref",yc_supporting_termination_point_ietf_network__networks_network_node_termination_point_supporting_termination_point, yang_name="supporting-termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref tp-ref', extensions=None), is_container='list', yang_name="supporting-termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'node', 'termination-point']

  def _get_tp_id(self):
    """
    Getter method for tp_id, mapped from YANG variable /networks/network/node/termination_point/tp_id (tp-id)

    YANG Description: Termination point identifier.
    """
    return self.__tp_id
      
  def _set_tp_id(self, v, load=False):
    """
    Setter method for tp_id, mapped from YANG variable /networks/network/node/termination_point/tp_id (tp-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_tp_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_tp_id() directly.

    YANG Description: Termination point identifier.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="tp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='tp-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """tp_id must be of a type compatible with tp-id""",
          'defined-type': "ietf-network-topology:tp-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='tp-id', is_config=True)""",
        })

    self.__tp_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_tp_id(self):
    self.__tp_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="tp-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='tp-id', is_config=True)


  def _get_supporting_termination_point(self):
    """
    Getter method for supporting_termination_point, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point (list)

    YANG Description: This list identifies any termination points on which a
given termination point depends or onto which it maps.
Those termination points will themselves be contained
in a supporting node.  This dependency information can be
inferred from the dependencies between links.  Therefore,
this item is not separately configurable.  Hence, no
corresponding constraint needs to be articulated.
The corresponding information is simply provided by the
implementing system.
    """
    return self.__supporting_termination_point
      
  def _set_supporting_termination_point(self, v, load=False):
    """
    Setter method for supporting_termination_point, mapped from YANG variable /networks/network/node/termination_point/supporting_termination_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_termination_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_termination_point() directly.

    YANG Description: This list identifies any termination points on which a
given termination point depends or onto which it maps.
Those termination points will themselves be contained
in a supporting node.  This dependency information can be
inferred from the dependencies between links.  Therefore,
this item is not separately configurable.  Hence, no
corresponding constraint needs to be articulated.
The corresponding information is simply provided by the
implementing system.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref node_ref tp_ref",yc_supporting_termination_point_ietf_network__networks_network_node_termination_point_supporting_termination_point, yang_name="supporting-termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref tp-ref', extensions=None), is_container='list', yang_name="supporting-termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_termination_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref node_ref tp_ref",yc_supporting_termination_point_ietf_network__networks_network_node_termination_point_supporting_termination_point, yang_name="supporting-termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref tp-ref', extensions=None), is_container='list', yang_name="supporting-termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)""",
        })

    self.__supporting_termination_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_termination_point(self):
    self.__supporting_termination_point = YANGDynClass(base=YANGListType("network_ref node_ref tp_ref",yc_supporting_termination_point_ietf_network__networks_network_node_termination_point_supporting_termination_point, yang_name="supporting-termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref tp-ref', extensions=None), is_container='list', yang_name="supporting-termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

  tp_id = __builtin__.property(_get_tp_id, _set_tp_id)
  supporting_termination_point = __builtin__.property(_get_supporting_termination_point, _set_supporting_termination_point)


  _pyangbind_elements = OrderedDict([('tp_id', tp_id), ('supporting_termination_point', supporting_termination_point), ])


class yc_node_ietf_network__networks_network_node(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The inventory of nodes of this network.
  """
  __slots__ = ('_path_helper', '_extmethods', '__node_id','__supporting_node','__termination_point',)

  _yang_name = 'node'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)
    self.__supporting_node = YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    self.__termination_point = YANGDynClass(base=YANGListType("tp_id",yc_termination_point_ietf_network__networks_network_node_termination_point, yang_name="termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='tp-id', extensions=None), is_container='list', yang_name="termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'node']

  def _get_node_id(self):
    """
    Getter method for node_id, mapped from YANG variable /networks/network/node/node_id (node-id)

    YANG Description: Uniquely identifies a node within the containing
network.
    """
    return self.__node_id
      
  def _set_node_id(self, v, load=False):
    """
    Setter method for node_id, mapped from YANG variable /networks/network/node/node_id (node-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_id() directly.

    YANG Description: Uniquely identifies a node within the containing
network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node_id must be of a type compatible with node-id""",
          'defined-type': "ietf-network:node-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)""",
        })

    self.__node_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node_id(self):
    self.__node_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="node-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='node-id', is_config=True)


  def _get_supporting_node(self):
    """
    Getter method for supporting_node, mapped from YANG variable /networks/network/node/supporting_node (list)

    YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
    """
    return self.__supporting_node
      
  def _set_supporting_node(self, v, load=False):
    """
    Setter method for supporting_node, mapped from YANG variable /networks/network/node/supporting_node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_node() directly.

    YANG Description: Represents another node that is in an underlay network
and that supports this node.  Used to represent layering
structure.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__supporting_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_node(self):
    self.__supporting_node = YANGDynClass(base=YANGListType("network_ref node_ref",yc_supporting_node_ietf_network__networks_network_node_supporting_node, yang_name="supporting-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref node-ref', extensions=None), is_container='list', yang_name="supporting-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)


  def _get_termination_point(self):
    """
    Getter method for termination_point, mapped from YANG variable /networks/network/node/termination_point (list)

    YANG Description: A termination point can terminate a link.
Depending on the type of topology, a termination point
could, for example, refer to a port or an interface.
    """
    return self.__termination_point
      
  def _set_termination_point(self, v, load=False):
    """
    Setter method for termination_point, mapped from YANG variable /networks/network/node/termination_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_termination_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_termination_point() directly.

    YANG Description: A termination point can terminate a link.
Depending on the type of topology, a termination point
could, for example, refer to a port or an interface.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("tp_id",yc_termination_point_ietf_network__networks_network_node_termination_point, yang_name="termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='tp-id', extensions=None), is_container='list', yang_name="termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """termination_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("tp_id",yc_termination_point_ietf_network__networks_network_node_termination_point, yang_name="termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='tp-id', extensions=None), is_container='list', yang_name="termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)""",
        })

    self.__termination_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_termination_point(self):
    self.__termination_point = YANGDynClass(base=YANGListType("tp_id",yc_termination_point_ietf_network__networks_network_node_termination_point, yang_name="termination-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='tp-id', extensions=None), is_container='list', yang_name="termination-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

  node_id = __builtin__.property(_get_node_id, _set_node_id)
  supporting_node = __builtin__.property(_get_supporting_node, _set_supporting_node)
  termination_point = __builtin__.property(_get_termination_point, _set_termination_point)


  _pyangbind_elements = OrderedDict([('node_id', node_id), ('supporting_node', supporting_node), ('termination_point', termination_point), ])


class yc_source_ietf_network__networks_network_link_source(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/link/source. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container holds the logical source of a particular
link.
  """
  __slots__ = ('_path_helper', '_extmethods', '__source_node','__source_tp',)

  _yang_name = 'source'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__source_node = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    self.__source_tp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'link', 'source']

  def _get_source_node(self):
    """
    Getter method for source_node, mapped from YANG variable /networks/network/link/source/source_node (leafref)

    YANG Description: Source node identifier.  Must be in the same topology.
    """
    return self.__source_node
      
  def _set_source_node(self, v, load=False):
    """
    Setter method for source_node, mapped from YANG variable /networks/network/link/source/source_node (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_node() directly.

    YANG Description: Source node identifier.  Must be in the same topology.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="source-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_node must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__source_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_node(self):
    self.__source_node = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)


  def _get_source_tp(self):
    """
    Getter method for source_tp, mapped from YANG variable /networks/network/link/source/source_tp (leafref)

    YANG Description: This termination point is located within the source node
and terminates the link.
    """
    return self.__source_tp
      
  def _set_source_tp(self, v, load=False):
    """
    Setter method for source_tp, mapped from YANG variable /networks/network/link/source/source_tp (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source_tp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source_tp() directly.

    YANG Description: This termination point is located within the source node
and terminates the link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="source-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source_tp must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__source_tp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source_tp(self):
    self.__source_tp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="source-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

  source_node = __builtin__.property(_get_source_node, _set_source_node)
  source_tp = __builtin__.property(_get_source_tp, _set_source_tp)


  _pyangbind_elements = OrderedDict([('source_node', source_node), ('source_tp', source_tp), ])


class yc_destination_ietf_network__networks_network_link_destination(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/link/destination. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This container holds the logical destination of a
particular link.
  """
  __slots__ = ('_path_helper', '_extmethods', '__dest_node','__dest_tp',)

  _yang_name = 'destination'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__dest_node = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dest-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    self.__dest_tp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dest-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'link', 'destination']

  def _get_dest_node(self):
    """
    Getter method for dest_node, mapped from YANG variable /networks/network/link/destination/dest_node (leafref)

    YANG Description: Destination node identifier.  Must be in the same
network.
    """
    return self.__dest_node
      
  def _set_dest_node(self, v, load=False):
    """
    Setter method for dest_node, mapped from YANG variable /networks/network/link/destination/dest_node (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_node() directly.

    YANG Description: Destination node identifier.  Must be in the same
network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dest-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_node must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dest-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__dest_node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_node(self):
    self.__dest_node = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dest-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)


  def _get_dest_tp(self):
    """
    Getter method for dest_tp, mapped from YANG variable /networks/network/link/destination/dest_tp (leafref)

    YANG Description: This termination point is located within the
destination node and terminates the link.
    """
    return self.__dest_tp
      
  def _set_dest_tp(self, v, load=False):
    """
    Setter method for dest_tp, mapped from YANG variable /networks/network/link/destination/dest_tp (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dest_tp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dest_tp() directly.

    YANG Description: This termination point is located within the
destination node and terminates the link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="dest-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """dest_tp must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dest-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__dest_tp = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_dest_tp(self):
    self.__dest_tp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="dest-tp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

  dest_node = __builtin__.property(_get_dest_node, _set_dest_node)
  dest_tp = __builtin__.property(_get_dest_tp, _set_dest_tp)


  _pyangbind_elements = OrderedDict([('dest_node', dest_node), ('dest_tp', dest_tp), ])


class yc_supporting_link_ietf_network__networks_network_link_supporting_link(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/link/supporting-link. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies the link or links on which this link depends.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_ref','__link_ref',)

  _yang_name = 'supporting-link'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    self.__link_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="link-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'link', 'supporting-link']

  def _get_network_ref(self):
    """
    Getter method for network_ref, mapped from YANG variable /networks/network/link/supporting_link/network_ref (leafref)

    YANG Description: This leaf identifies in which underlay topology
the supporting link is present.
    """
    return self.__network_ref
      
  def _set_network_ref(self, v, load=False):
    """
    Setter method for network_ref, mapped from YANG variable /networks/network/link/supporting_link/network_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_ref() directly.

    YANG Description: This leaf identifies in which underlay topology
the supporting link is present.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__network_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_ref(self):
    self.__network_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)


  def _get_link_ref(self):
    """
    Getter method for link_ref, mapped from YANG variable /networks/network/link/supporting_link/link_ref (leafref)

    YANG Description: This leaf identifies a link that is a part
of this link's underlay.  Reference loops in which
a link identifies itself as its underlay, either
directly or transitively, are not allowed.
    """
    return self.__link_ref
      
  def _set_link_ref(self, v, load=False):
    """
    Setter method for link_ref, mapped from YANG variable /networks/network/link/supporting_link/link_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_ref() directly.

    YANG Description: This leaf identifies a link that is a part
of this link's underlay.  Reference loops in which
a link identifies itself as its underlay, either
directly or transitively, are not allowed.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="link-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_ref must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="link-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)""",
        })

    self.__link_ref = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_ref(self):
    self.__link_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="link-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='leafref', is_config=True)

  network_ref = __builtin__.property(_get_network_ref, _set_network_ref)
  link_ref = __builtin__.property(_get_link_ref, _set_link_ref)


  _pyangbind_elements = OrderedDict([('network_ref', network_ref), ('link_ref', link_ref), ])


class yc_link_ietf_network__networks_network_link(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network/link. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A network link connects a local (source) node and
a remote (destination) node via a set of the respective
node's termination points.  It is possible to have several
links between the same source and destination nodes.
Likewise, a link could potentially be re-homed between
termination points.  Therefore, in order to ensure that we
would always know to distinguish between links, every link
is identified by a dedicated link identifier.  Note that a
link models a point-to-point link, not a multipoint link.
  """
  __slots__ = ('_path_helper', '_extmethods', '__link_id','__source','__destination','__supporting_link',)

  _yang_name = 'link'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__link_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='link-id', is_config=True)
    self.__source = YANGDynClass(base=yc_source_ietf_network__networks_network_link_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)
    self.__destination = YANGDynClass(base=yc_destination_ietf_network__networks_network_link_destination, is_container='container', yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)
    self.__supporting_link = YANGDynClass(base=YANGListType("network_ref link_ref",yc_supporting_link_ietf_network__networks_network_link_supporting_link, yang_name="supporting-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref link-ref', extensions=None), is_container='list', yang_name="supporting-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network', 'link']

  def _get_link_id(self):
    """
    Getter method for link_id, mapped from YANG variable /networks/network/link/link_id (link-id)

    YANG Description: The identifier of a link in the topology.
A link is specific to a topology to which it belongs.
    """
    return self.__link_id
      
  def _set_link_id(self, v, load=False):
    """
    Setter method for link_id, mapped from YANG variable /networks/network/link/link_id (link-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link_id() directly.

    YANG Description: The identifier of a link in the topology.
A link is specific to a topology to which it belongs.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='link-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link_id must be of a type compatible with link-id""",
          'defined-type': "ietf-network-topology:link-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='link-id', is_config=True)""",
        })

    self.__link_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link_id(self):
    self.__link_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="link-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='link-id', is_config=True)


  def _get_source(self):
    """
    Getter method for source, mapped from YANG variable /networks/network/link/source (container)

    YANG Description: This container holds the logical source of a particular
link.
    """
    return self.__source
      
  def _set_source(self, v, load=False):
    """
    Setter method for source, mapped from YANG variable /networks/network/link/source (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: This container holds the logical source of a particular
link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_source_ietf_network__networks_network_link_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """source must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_source_ietf_network__networks_network_link_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)""",
        })

    self.__source = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_source(self):
    self.__source = YANGDynClass(base=yc_source_ietf_network__networks_network_link_source, is_container='container', yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)


  def _get_destination(self):
    """
    Getter method for destination, mapped from YANG variable /networks/network/link/destination (container)

    YANG Description: This container holds the logical destination of a
particular link.
    """
    return self.__destination
      
  def _set_destination(self, v, load=False):
    """
    Setter method for destination, mapped from YANG variable /networks/network/link/destination (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_destination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_destination() directly.

    YANG Description: This container holds the logical destination of a
particular link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_destination_ietf_network__networks_network_link_destination, is_container='container', yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """destination must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_destination_ietf_network__networks_network_link_destination, is_container='container', yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)""",
        })

    self.__destination = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_destination(self):
    self.__destination = YANGDynClass(base=yc_destination_ietf_network__networks_network_link_destination, is_container='container', yang_name="destination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='container', is_config=True)


  def _get_supporting_link(self):
    """
    Getter method for supporting_link, mapped from YANG variable /networks/network/link/supporting_link (list)

    YANG Description: Identifies the link or links on which this link depends.
    """
    return self.__supporting_link
      
  def _set_supporting_link(self, v, load=False):
    """
    Setter method for supporting_link, mapped from YANG variable /networks/network/link/supporting_link (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_link() directly.

    YANG Description: Identifies the link or links on which this link depends.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref link_ref",yc_supporting_link_ietf_network__networks_network_link_supporting_link, yang_name="supporting-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref link-ref', extensions=None), is_container='list', yang_name="supporting-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_link must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref link_ref",yc_supporting_link_ietf_network__networks_network_link_supporting_link, yang_name="supporting-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref link-ref', extensions=None), is_container='list', yang_name="supporting-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)""",
        })

    self.__supporting_link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_link(self):
    self.__supporting_link = YANGDynClass(base=YANGListType("network_ref link_ref",yc_supporting_link_ietf_network__networks_network_link_supporting_link, yang_name="supporting-link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref link-ref', extensions=None), is_container='list', yang_name="supporting-link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

  link_id = __builtin__.property(_get_link_id, _set_link_id)
  source = __builtin__.property(_get_source, _set_source)
  destination = __builtin__.property(_get_destination, _set_destination)
  supporting_link = __builtin__.property(_get_supporting_link, _set_supporting_link)


  _pyangbind_elements = OrderedDict([('link_id', link_id), ('source', source), ('destination', destination), ('supporting_link', supporting_link), ])


class yc_network_ietf_network__networks_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks/network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network_id','__supporting_network','__node','__link',)

  _yang_name = 'network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)
    self.__supporting_network = YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    self.__node = YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    self.__link = YANGDynClass(base=YANGListType("link_id",yc_link_ietf_network__networks_network_link, yang_name="link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id', extensions=None), is_container='list', yang_name="link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks', 'network']

  def _get_network_id(self):
    """
    Getter method for network_id, mapped from YANG variable /networks/network/network_id (network-id)

    YANG Description: Identifies a network.
    """
    return self.__network_id
      
  def _set_network_id(self, v, load=False):
    """
    Setter method for network_id, mapped from YANG variable /networks/network/network_id (network-id)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_id() directly.

    YANG Description: Identifies a network.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network_id must be of a type compatible with network-id""",
          'defined-type': "ietf-network:network-id",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)""",
        })

    self.__network_id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network_id(self):
    self.__network_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="network-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='network-id', is_config=True)


  def _get_supporting_network(self):
    """
    Getter method for supporting_network, mapped from YANG variable /networks/network/supporting_network (list)

    YANG Description: An underlay network, used to represent layered network
topologies.
    """
    return self.__supporting_network
      
  def _set_supporting_network(self, v, load=False):
    """
    Setter method for supporting_network, mapped from YANG variable /networks/network/supporting_network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supporting_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supporting_network() directly.

    YANG Description: An underlay network, used to represent layered network
topologies.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supporting_network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__supporting_network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supporting_network(self):
    self.__supporting_network = YANGDynClass(base=YANGListType("network_ref",yc_supporting_network_ietf_network__networks_network_supporting_network, yang_name="supporting-network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-ref', extensions=None), is_container='list', yang_name="supporting-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)


  def _get_node(self):
    """
    Getter method for node, mapped from YANG variable /networks/network/node (list)

    YANG Description: The inventory of nodes of this network.
    """
    return self.__node
      
  def _set_node(self, v, load=False):
    """
    Setter method for node, mapped from YANG variable /networks/network/node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node() directly.

    YANG Description: The inventory of nodes of this network.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """node must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__node = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_node(self):
    self.__node = YANGDynClass(base=YANGListType("node_id",yc_node_ietf_network__networks_network_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='node-id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)


  def _get_link(self):
    """
    Getter method for link, mapped from YANG variable /networks/network/link (list)

    YANG Description: A network link connects a local (source) node and
a remote (destination) node via a set of the respective
node's termination points.  It is possible to have several
links between the same source and destination nodes.
Likewise, a link could potentially be re-homed between
termination points.  Therefore, in order to ensure that we
would always know to distinguish between links, every link
is identified by a dedicated link identifier.  Note that a
link models a point-to-point link, not a multipoint link.
    """
    return self.__link
      
  def _set_link(self, v, load=False):
    """
    Setter method for link, mapped from YANG variable /networks/network/link (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_link is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_link() directly.

    YANG Description: A network link connects a local (source) node and
a remote (destination) node via a set of the respective
node's termination points.  It is possible to have several
links between the same source and destination nodes.
Likewise, a link could potentially be re-homed between
termination points.  Therefore, in order to ensure that we
would always know to distinguish between links, every link
is identified by a dedicated link identifier.  Note that a
link models a point-to-point link, not a multipoint link.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("link_id",yc_link_ietf_network__networks_network_link, yang_name="link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id', extensions=None), is_container='list', yang_name="link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """link must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("link_id",yc_link_ietf_network__networks_network_link, yang_name="link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id', extensions=None), is_container='list', yang_name="link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)""",
        })

    self.__link = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_link(self):
    self.__link = YANGDynClass(base=YANGListType("link_id",yc_link_ietf_network__networks_network_link, yang_name="link", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='link-id', extensions=None), is_container='list', yang_name="link", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network-topology', defining_module='ietf-network-topology', yang_type='list', is_config=True)

  network_id = __builtin__.property(_get_network_id, _set_network_id)
  supporting_network = __builtin__.property(_get_supporting_network, _set_supporting_network)
  node = __builtin__.property(_get_node, _set_node)
  link = __builtin__.property(_get_link, _set_link)


  _pyangbind_elements = OrderedDict([('network_id', network_id), ('supporting_network', supporting_network), ('node', node), ('link', link), ])


class yc_networks_ietf_network__networks(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /networks. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Serves as a top-level container for a list of networks.
  """
  __slots__ = ('_path_helper', '_extmethods', '__network',)

  _yang_name = 'networks'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__network = YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['networks']

  def _get_network(self):
    """
    Getter method for network, mapped from YANG variable /networks/network (list)

    YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
    """
    return self.__network
      
  def _set_network(self, v, load=False):
    """
    Setter method for network, mapped from YANG variable /networks/network (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network() directly.

    YANG Description: Describes a network.
A network typically contains an inventory of nodes,
topological information (augmented through the
network-topology data model), and layering information.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """network must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)""",
        })

    self.__network = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_network(self):
    self.__network = YANGDynClass(base=YANGListType("network_id",yc_network_ietf_network__networks_network, yang_name="network", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='network-id', extensions=None), is_container='list', yang_name="network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='list', is_config=True)

  network = __builtin__.property(_get_network, _set_network)


  _pyangbind_elements = OrderedDict([('network', network), ])


class ietf_network(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network - based on the path /ietf-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a common base data model for a collection
of nodes in a network.  Node definitions are further used
in network topologies and inventories.

Copyright (c) 2018 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8345;
see the RFC itself for full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__networks',)

  _yang_name = 'ietf-network'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__networks = YANGDynClass(base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_networks(self):
    """
    Getter method for networks, mapped from YANG variable /networks (container)

    YANG Description: Serves as a top-level container for a list of networks.
    """
    return self.__networks
      
  def _set_networks(self, v, load=False):
    """
    Setter method for networks, mapped from YANG variable /networks (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_networks is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_networks() directly.

    YANG Description: Serves as a top-level container for a list of networks.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """networks must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)""",
        })

    self.__networks = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_networks(self):
    self.__networks = YANGDynClass(base=yc_networks_ietf_network__networks, is_container='container', yang_name="networks", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-network', defining_module='ietf-network', yang_type='container', is_config=True)

  networks = __builtin__.property(_get_networks, _set_networks)


  _pyangbind_elements = OrderedDict([('networks', networks), ])


class ietf_network_topology(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-network-topology - based on the path /ietf-network-topology. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a common base model for a network topology,
augmenting the base network data model with links to connect
nodes, as well as termination points to terminate links
on nodes.

Copyright (c) 2018 IETF Trust and the persons identified as
authors of the code.  All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).

This version of this YANG module is part of RFC 8345;
see the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

