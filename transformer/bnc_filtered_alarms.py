# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class yc_attributes_bnc_filtered_alarms__bncFilteredAlarm_alarm_attributes(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module bnc-filtered-alarms - based on the path /bncFilteredAlarm/alarm/attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__alarmId','__nodeId','__raAlarmId','__nodeType','__state','__resourceId','__nativeConditionType','__conditionSeverity','__serviceAffecting','__manualClearable','__additionalText','__firstRaiseTime','__lastRaiseTime','__numberOfOccurrences','__acknowledgeState','__deviceId','__deviceName','__deviceLongName','__ipAddress','__macAddress','__cardType','__fic','__partition',)

  _yang_name = 'attributes'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__alarmId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__nodeId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__raAlarmId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="raAlarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__nodeType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nodeType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__state = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__resourceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="resourceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__nativeConditionType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nativeConditionType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__conditionSeverity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="conditionSeverity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__serviceAffecting = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serviceAffecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__manualClearable = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="manualClearable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__additionalText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="additionalText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__firstRaiseTime = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firstRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__lastRaiseTime = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lastRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__numberOfOccurrences = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfOccurrences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='uint32', is_config=True)
    self.__acknowledgeState = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acknowledgeState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__deviceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__deviceName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__deviceLongName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceLongName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__ipAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__macAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="macAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__cardType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cardType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__fic = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__partition = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="partition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bncFilteredAlarm', 'alarm', 'attributes']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_alarmId(self):
    """
    Getter method for alarmId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/alarmId (string)
    """
    return self.__alarmId
      
  def _set_alarmId(self, v, load=False):
    """
    Setter method for alarmId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/alarmId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarmId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarmId() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="alarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarmId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__alarmId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarmId(self):
    self.__alarmId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_nodeId(self):
    """
    Getter method for nodeId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/nodeId (string)
    """
    return self.__nodeId
      
  def _set_nodeId(self, v, load=False):
    """
    Setter method for nodeId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/nodeId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nodeId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nodeId() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nodeId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__nodeId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nodeId(self):
    self.__nodeId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nodeId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_raAlarmId(self):
    """
    Getter method for raAlarmId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/raAlarmId (string)
    """
    return self.__raAlarmId
      
  def _set_raAlarmId(self, v, load=False):
    """
    Setter method for raAlarmId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/raAlarmId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_raAlarmId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_raAlarmId() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="raAlarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """raAlarmId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="raAlarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__raAlarmId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_raAlarmId(self):
    self.__raAlarmId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="raAlarmId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_nodeType(self):
    """
    Getter method for nodeType, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/nodeType (string)
    """
    return self.__nodeType
      
  def _set_nodeType(self, v, load=False):
    """
    Setter method for nodeType, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/nodeType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nodeType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nodeType() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nodeType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nodeType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nodeType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__nodeType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nodeType(self):
    self.__nodeType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nodeType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_state(self):
    """
    Getter method for state, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/state (string)
    """
    return self.__state
      
  def _set_state(self, v, load=False):
    """
    Setter method for state, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/state (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_state is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_state() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """state must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__state = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_state(self):
    self.__state = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="state", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_resourceId(self):
    """
    Getter method for resourceId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/resourceId (string)
    """
    return self.__resourceId
      
  def _set_resourceId(self, v, load=False):
    """
    Setter method for resourceId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/resourceId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_resourceId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_resourceId() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="resourceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """resourceId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="resourceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__resourceId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_resourceId(self):
    self.__resourceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="resourceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_nativeConditionType(self):
    """
    Getter method for nativeConditionType, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/nativeConditionType (string)
    """
    return self.__nativeConditionType
      
  def _set_nativeConditionType(self, v, load=False):
    """
    Setter method for nativeConditionType, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/nativeConditionType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nativeConditionType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nativeConditionType() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="nativeConditionType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """nativeConditionType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nativeConditionType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__nativeConditionType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_nativeConditionType(self):
    self.__nativeConditionType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nativeConditionType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_conditionSeverity(self):
    """
    Getter method for conditionSeverity, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/conditionSeverity (string)
    """
    return self.__conditionSeverity
      
  def _set_conditionSeverity(self, v, load=False):
    """
    Setter method for conditionSeverity, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/conditionSeverity (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_conditionSeverity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_conditionSeverity() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="conditionSeverity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """conditionSeverity must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="conditionSeverity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__conditionSeverity = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_conditionSeverity(self):
    self.__conditionSeverity = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="conditionSeverity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_serviceAffecting(self):
    """
    Getter method for serviceAffecting, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/serviceAffecting (string)
    """
    return self.__serviceAffecting
      
  def _set_serviceAffecting(self, v, load=False):
    """
    Setter method for serviceAffecting, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/serviceAffecting (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_serviceAffecting is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_serviceAffecting() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="serviceAffecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """serviceAffecting must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serviceAffecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__serviceAffecting = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_serviceAffecting(self):
    self.__serviceAffecting = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="serviceAffecting", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_manualClearable(self):
    """
    Getter method for manualClearable, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/manualClearable (string)
    """
    return self.__manualClearable
      
  def _set_manualClearable(self, v, load=False):
    """
    Setter method for manualClearable, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/manualClearable (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_manualClearable is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_manualClearable() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="manualClearable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """manualClearable must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="manualClearable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__manualClearable = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_manualClearable(self):
    self.__manualClearable = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="manualClearable", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_additionalText(self):
    """
    Getter method for additionalText, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/additionalText (string)
    """
    return self.__additionalText
      
  def _set_additionalText(self, v, load=False):
    """
    Setter method for additionalText, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/additionalText (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_additionalText is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_additionalText() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="additionalText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """additionalText must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="additionalText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__additionalText = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_additionalText(self):
    self.__additionalText = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="additionalText", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_firstRaiseTime(self):
    """
    Getter method for firstRaiseTime, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/firstRaiseTime (string)
    """
    return self.__firstRaiseTime
      
  def _set_firstRaiseTime(self, v, load=False):
    """
    Setter method for firstRaiseTime, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/firstRaiseTime (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_firstRaiseTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_firstRaiseTime() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="firstRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """firstRaiseTime must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firstRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__firstRaiseTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_firstRaiseTime(self):
    self.__firstRaiseTime = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="firstRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_lastRaiseTime(self):
    """
    Getter method for lastRaiseTime, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/lastRaiseTime (string)
    """
    return self.__lastRaiseTime
      
  def _set_lastRaiseTime(self, v, load=False):
    """
    Setter method for lastRaiseTime, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/lastRaiseTime (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lastRaiseTime is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lastRaiseTime() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="lastRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """lastRaiseTime must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lastRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__lastRaiseTime = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_lastRaiseTime(self):
    self.__lastRaiseTime = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="lastRaiseTime", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_numberOfOccurrences(self):
    """
    Getter method for numberOfOccurrences, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/numberOfOccurrences (uint32)
    """
    return self.__numberOfOccurrences
      
  def _set_numberOfOccurrences(self, v, load=False):
    """
    Setter method for numberOfOccurrences, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/numberOfOccurrences (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numberOfOccurrences is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numberOfOccurrences() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfOccurrences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """numberOfOccurrences must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfOccurrences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='uint32', is_config=True)""",
        })

    self.__numberOfOccurrences = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_numberOfOccurrences(self):
    self.__numberOfOccurrences = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="numberOfOccurrences", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='uint32', is_config=True)


  def _get_acknowledgeState(self):
    """
    Getter method for acknowledgeState, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/acknowledgeState (string)
    """
    return self.__acknowledgeState
      
  def _set_acknowledgeState(self, v, load=False):
    """
    Setter method for acknowledgeState, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/acknowledgeState (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_acknowledgeState is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_acknowledgeState() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="acknowledgeState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """acknowledgeState must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acknowledgeState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__acknowledgeState = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_acknowledgeState(self):
    self.__acknowledgeState = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="acknowledgeState", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_deviceId(self):
    """
    Getter method for deviceId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/deviceId (string)
    """
    return self.__deviceId
      
  def _set_deviceId(self, v, load=False):
    """
    Setter method for deviceId, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/deviceId (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deviceId is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deviceId() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="deviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """deviceId must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__deviceId = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_deviceId(self):
    self.__deviceId = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceId", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_deviceName(self):
    """
    Getter method for deviceName, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/deviceName (string)
    """
    return self.__deviceName
      
  def _set_deviceName(self, v, load=False):
    """
    Setter method for deviceName, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/deviceName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deviceName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deviceName() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="deviceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """deviceName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__deviceName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_deviceName(self):
    self.__deviceName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_deviceLongName(self):
    """
    Getter method for deviceLongName, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/deviceLongName (string)
    """
    return self.__deviceLongName
      
  def _set_deviceLongName(self, v, load=False):
    """
    Setter method for deviceLongName, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/deviceLongName (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deviceLongName is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deviceLongName() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="deviceLongName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """deviceLongName must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceLongName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__deviceLongName = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_deviceLongName(self):
    self.__deviceLongName = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="deviceLongName", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_ipAddress(self):
    """
    Getter method for ipAddress, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/ipAddress (string)
    """
    return self.__ipAddress
      
  def _set_ipAddress(self, v, load=False):
    """
    Setter method for ipAddress, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/ipAddress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipAddress() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """ipAddress must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__ipAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_ipAddress(self):
    self.__ipAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ipAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_macAddress(self):
    """
    Getter method for macAddress, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/macAddress (string)
    """
    return self.__macAddress
      
  def _set_macAddress(self, v, load=False):
    """
    Setter method for macAddress, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/macAddress (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_macAddress is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_macAddress() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="macAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """macAddress must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="macAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__macAddress = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_macAddress(self):
    self.__macAddress = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="macAddress", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_cardType(self):
    """
    Getter method for cardType, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/cardType (string)
    """
    return self.__cardType
      
  def _set_cardType(self, v, load=False):
    """
    Setter method for cardType, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/cardType (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cardType is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cardType() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="cardType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cardType must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cardType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__cardType = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cardType(self):
    self.__cardType = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cardType", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_fic(self):
    """
    Getter method for fic, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/fic (string)
    """
    return self.__fic
      
  def _set_fic(self, v, load=False):
    """
    Setter method for fic, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/fic (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_fic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_fic() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="fic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """fic must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__fic = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_fic(self):
    self.__fic = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="fic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_partition(self):
    """
    Getter method for partition, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/partition (string)
    """
    return self.__partition
      
  def _set_partition(self, v, load=False):
    """
    Setter method for partition, mapped from YANG variable /bncFilteredAlarm/alarm/attributes/partition (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_partition is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_partition() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="partition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """partition must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="partition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__partition = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_partition(self):
    self.__partition = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="partition", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  alarmId = __builtin__.property(_get_alarmId, _set_alarmId)
  nodeId = __builtin__.property(_get_nodeId, _set_nodeId)
  raAlarmId = __builtin__.property(_get_raAlarmId, _set_raAlarmId)
  nodeType = __builtin__.property(_get_nodeType, _set_nodeType)
  state = __builtin__.property(_get_state, _set_state)
  resourceId = __builtin__.property(_get_resourceId, _set_resourceId)
  nativeConditionType = __builtin__.property(_get_nativeConditionType, _set_nativeConditionType)
  conditionSeverity = __builtin__.property(_get_conditionSeverity, _set_conditionSeverity)
  serviceAffecting = __builtin__.property(_get_serviceAffecting, _set_serviceAffecting)
  manualClearable = __builtin__.property(_get_manualClearable, _set_manualClearable)
  additionalText = __builtin__.property(_get_additionalText, _set_additionalText)
  firstRaiseTime = __builtin__.property(_get_firstRaiseTime, _set_firstRaiseTime)
  lastRaiseTime = __builtin__.property(_get_lastRaiseTime, _set_lastRaiseTime)
  numberOfOccurrences = __builtin__.property(_get_numberOfOccurrences, _set_numberOfOccurrences)
  acknowledgeState = __builtin__.property(_get_acknowledgeState, _set_acknowledgeState)
  deviceId = __builtin__.property(_get_deviceId, _set_deviceId)
  deviceName = __builtin__.property(_get_deviceName, _set_deviceName)
  deviceLongName = __builtin__.property(_get_deviceLongName, _set_deviceLongName)
  ipAddress = __builtin__.property(_get_ipAddress, _set_ipAddress)
  macAddress = __builtin__.property(_get_macAddress, _set_macAddress)
  cardType = __builtin__.property(_get_cardType, _set_cardType)
  fic = __builtin__.property(_get_fic, _set_fic)
  partition = __builtin__.property(_get_partition, _set_partition)


  _pyangbind_elements = OrderedDict([('id', id), ('alarmId', alarmId), ('nodeId', nodeId), ('raAlarmId', raAlarmId), ('nodeType', nodeType), ('state', state), ('resourceId', resourceId), ('nativeConditionType', nativeConditionType), ('conditionSeverity', conditionSeverity), ('serviceAffecting', serviceAffecting), ('manualClearable', manualClearable), ('additionalText', additionalText), ('firstRaiseTime', firstRaiseTime), ('lastRaiseTime', lastRaiseTime), ('numberOfOccurrences', numberOfOccurrences), ('acknowledgeState', acknowledgeState), ('deviceId', deviceId), ('deviceName', deviceName), ('deviceLongName', deviceLongName), ('ipAddress', ipAddress), ('macAddress', macAddress), ('cardType', cardType), ('fic', fic), ('partition', partition), ])


class yc_alarm_bnc_filtered_alarms__bncFilteredAlarm_alarm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module bnc-filtered-alarms - based on the path /bncFilteredAlarm/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__id','__type','__attributes',)

  _yang_name = 'alarm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    self.__attributes = YANGDynClass(base=yc_attributes_bnc_filtered_alarms__bncFilteredAlarm_alarm_attributes, is_container='container', yang_name="attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bncFilteredAlarm', 'alarm']

  def _get_id(self):
    """
    Getter method for id, mapped from YANG variable /bncFilteredAlarm/alarm/id (string)
    """
    return self.__id
      
  def _set_id(self, v, load=False):
    """
    Setter method for id, mapped from YANG variable /bncFilteredAlarm/alarm/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """id must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__id = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_id(self):
    self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_type(self):
    """
    Getter method for type, mapped from YANG variable /bncFilteredAlarm/alarm/type (string)
    """
    return self.__type
      
  def _set_type(self, v, load=False):
    """
    Setter method for type, mapped from YANG variable /bncFilteredAlarm/alarm/type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """type must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)""",
        })

    self.__type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_type(self):
    self.__type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='string', is_config=True)


  def _get_attributes(self):
    """
    Getter method for attributes, mapped from YANG variable /bncFilteredAlarm/alarm/attributes (container)
    """
    return self.__attributes
      
  def _set_attributes(self, v, load=False):
    """
    Setter method for attributes, mapped from YANG variable /bncFilteredAlarm/alarm/attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_attributes() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_attributes_bnc_filtered_alarms__bncFilteredAlarm_alarm_attributes, is_container='container', yang_name="attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """attributes must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_attributes_bnc_filtered_alarms__bncFilteredAlarm_alarm_attributes, is_container='container', yang_name="attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)""",
        })

    self.__attributes = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_attributes(self):
    self.__attributes = YANGDynClass(base=yc_attributes_bnc_filtered_alarms__bncFilteredAlarm_alarm_attributes, is_container='container', yang_name="attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)

  id = __builtin__.property(_get_id, _set_id)
  type = __builtin__.property(_get_type, _set_type)
  attributes = __builtin__.property(_get_attributes, _set_attributes)


  _pyangbind_elements = OrderedDict([('id', id), ('type', type), ('attributes', attributes), ])


class yc_bncFilteredAlarm_bnc_filtered_alarms__bncFilteredAlarm(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module bnc-filtered-alarms - based on the path /bncFilteredAlarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__alarm',)

  _yang_name = 'bncFilteredAlarm'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__alarm = YANGDynClass(base=YANGListType("id",yc_alarm_bnc_filtered_alarms__bncFilteredAlarm_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['bncFilteredAlarm']

  def _get_alarm(self):
    """
    Getter method for alarm, mapped from YANG variable /bncFilteredAlarm/alarm (list)
    """
    return self.__alarm
      
  def _set_alarm(self, v, load=False):
    """
    Setter method for alarm, mapped from YANG variable /bncFilteredAlarm/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("id",yc_alarm_bnc_filtered_alarms__bncFilteredAlarm_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """alarm must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("id",yc_alarm_bnc_filtered_alarms__bncFilteredAlarm_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='list', is_config=True)""",
        })

    self.__alarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_alarm(self):
    self.__alarm = YANGDynClass(base=YANGListType("id",yc_alarm_bnc_filtered_alarms__bncFilteredAlarm_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='list', is_config=True)

  alarm = __builtin__.property(_get_alarm, _set_alarm)


  _pyangbind_elements = OrderedDict([('alarm', alarm), ])


class bnc_filtered_alarms(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module bnc-filtered-alarms - based on the path /bnc-filtered-alarms. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__bncFilteredAlarm',)

  _yang_name = 'bnc-filtered-alarms'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__bncFilteredAlarm = YANGDynClass(base=yc_bncFilteredAlarm_bnc_filtered_alarms__bncFilteredAlarm, is_container='container', yang_name="bncFilteredAlarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_bncFilteredAlarm(self):
    """
    Getter method for bncFilteredAlarm, mapped from YANG variable /bncFilteredAlarm (container)
    """
    return self.__bncFilteredAlarm
      
  def _set_bncFilteredAlarm(self, v, load=False):
    """
    Setter method for bncFilteredAlarm, mapped from YANG variable /bncFilteredAlarm (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bncFilteredAlarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bncFilteredAlarm() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_bncFilteredAlarm_bnc_filtered_alarms__bncFilteredAlarm, is_container='container', yang_name="bncFilteredAlarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """bncFilteredAlarm must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_bncFilteredAlarm_bnc_filtered_alarms__bncFilteredAlarm, is_container='container', yang_name="bncFilteredAlarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)""",
        })

    self.__bncFilteredAlarm = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_bncFilteredAlarm(self):
    self.__bncFilteredAlarm = YANGDynClass(base=yc_bncFilteredAlarm_bnc_filtered_alarms__bncFilteredAlarm, is_container='container', yang_name="bncFilteredAlarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='https://rmt.verizon.com/bnc-filtered-alarms', defining_module='bnc-filtered-alarms', yang_type='container', is_config=True)

  bncFilteredAlarm = __builtin__.property(_get_bncFilteredAlarm, _set_bncFilteredAlarm)


  _pyangbind_elements = OrderedDict([('bncFilteredAlarm', bncFilteredAlarm), ])


